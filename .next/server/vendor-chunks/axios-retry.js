"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/axios-retry";
exports.ids = ["vendor-chunks/axios-retry"];
exports.modules = {

/***/ "(rsc)/./node_modules/axios-retry/dist/esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/axios-retry/dist/esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_OPTIONS: () => (/* binding */ DEFAULT_OPTIONS),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   exponentialDelay: () => (/* binding */ exponentialDelay),\n/* harmony export */   isIdempotentRequestError: () => (/* binding */ isIdempotentRequestError),\n/* harmony export */   isNetworkError: () => (/* binding */ isNetworkError),\n/* harmony export */   isNetworkOrIdempotentRequestError: () => (/* binding */ isNetworkOrIdempotentRequestError),\n/* harmony export */   isRetryableError: () => (/* binding */ isRetryableError),\n/* harmony export */   isSafeRequestError: () => (/* binding */ isSafeRequestError),\n/* harmony export */   linearDelay: () => (/* binding */ linearDelay),\n/* harmony export */   namespace: () => (/* binding */ namespace),\n/* harmony export */   retryAfter: () => (/* binding */ retryAfter)\n/* harmony export */ });\n/* harmony import */ var is_retry_allowed__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-retry-allowed */ \"(rsc)/./node_modules/is-retry-allowed/index.js\");\n\nconst namespace = 'axios-retry';\nfunction isNetworkError(error) {\n    const CODE_EXCLUDE_LIST = ['ERR_CANCELED', 'ECONNABORTED'];\n    if (error.response) {\n        return false;\n    }\n    if (!error.code) {\n        return false;\n    }\n    // Prevents retrying timed out & cancelled requests\n    if (CODE_EXCLUDE_LIST.includes(error.code)) {\n        return false;\n    }\n    // Prevents retrying unsafe errors\n    return is_retry_allowed__WEBPACK_IMPORTED_MODULE_0__(error);\n}\nconst SAFE_HTTP_METHODS = ['get', 'head', 'options'];\nconst IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(['put', 'delete']);\nfunction isRetryableError(error) {\n    return (error.code !== 'ECONNABORTED' &&\n        (!error.response ||\n            error.response.status === 429 ||\n            (error.response.status >= 500 && error.response.status <= 599)));\n}\nfunction isSafeRequestError(error) {\n    if (!error.config?.method) {\n        // Cannot determine if the request can be retried\n        return false;\n    }\n    return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\nfunction isIdempotentRequestError(error) {\n    if (!error.config?.method) {\n        // Cannot determine if the request can be retried\n        return false;\n    }\n    return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;\n}\nfunction isNetworkOrIdempotentRequestError(error) {\n    return isNetworkError(error) || isIdempotentRequestError(error);\n}\nfunction retryAfter(error = undefined) {\n    const retryAfterHeader = error?.response?.headers['retry-after'];\n    if (!retryAfterHeader) {\n        return 0;\n    }\n    // if the retry after header is a number, convert it to milliseconds\n    let retryAfterMs = (Number(retryAfterHeader) || 0) * 1000;\n    // If the retry after header is a date, get the number of milliseconds until that date\n    if (retryAfterMs === 0) {\n        retryAfterMs = (new Date(retryAfterHeader).valueOf() || 0) - Date.now();\n    }\n    return Math.max(0, retryAfterMs);\n}\nfunction noDelay(_retryNumber = 0, error = undefined) {\n    return Math.max(0, retryAfter(error));\n}\nfunction exponentialDelay(retryNumber = 0, error = undefined, delayFactor = 100) {\n    const calculatedDelay = 2 ** retryNumber * delayFactor;\n    const delay = Math.max(calculatedDelay, retryAfter(error));\n    const randomSum = delay * 0.2 * Math.random(); // 0-20% of the delay\n    return delay + randomSum;\n}\n/**\n * Linear delay\n * @param {number | undefined} delayFactor - delay factor in milliseconds (default: 100)\n * @returns {function} (retryNumber: number, error: AxiosError | undefined) => number\n */\nfunction linearDelay(delayFactor = 100) {\n    return (retryNumber = 0, error = undefined) => {\n        const delay = retryNumber * delayFactor;\n        return Math.max(delay, retryAfter(error));\n    };\n}\nconst DEFAULT_OPTIONS = {\n    retries: 3,\n    retryCondition: isNetworkOrIdempotentRequestError,\n    retryDelay: noDelay,\n    shouldResetTimeout: false,\n    onRetry: () => { },\n    onMaxRetryTimesExceeded: () => { },\n    validateResponse: null\n};\nfunction getRequestOptions(config, defaultOptions) {\n    return { ...DEFAULT_OPTIONS, ...defaultOptions, ...config[namespace] };\n}\nfunction setCurrentState(config, defaultOptions, resetLastRequestTime = false) {\n    const currentState = getRequestOptions(config, defaultOptions || {});\n    currentState.retryCount = currentState.retryCount || 0;\n    if (!currentState.lastRequestTime || resetLastRequestTime) {\n        currentState.lastRequestTime = Date.now();\n    }\n    config[namespace] = currentState;\n    return currentState;\n}\nfunction fixConfig(axiosInstance, config) {\n    // @ts-ignore\n    if (axiosInstance.defaults.agent === config.agent) {\n        // @ts-ignore\n        delete config.agent;\n    }\n    if (axiosInstance.defaults.httpAgent === config.httpAgent) {\n        delete config.httpAgent;\n    }\n    if (axiosInstance.defaults.httpsAgent === config.httpsAgent) {\n        delete config.httpsAgent;\n    }\n}\nasync function shouldRetry(currentState, error) {\n    const { retries, retryCondition } = currentState;\n    const shouldRetryOrPromise = (currentState.retryCount || 0) < retries && retryCondition(error);\n    // This could be a promise\n    if (typeof shouldRetryOrPromise === 'object') {\n        try {\n            const shouldRetryPromiseResult = await shouldRetryOrPromise;\n            // keep return true unless shouldRetryPromiseResult return false for compatibility\n            return shouldRetryPromiseResult !== false;\n        }\n        catch (_err) {\n            return false;\n        }\n    }\n    return shouldRetryOrPromise;\n}\nasync function handleRetry(axiosInstance, currentState, error, config) {\n    currentState.retryCount += 1;\n    const { retryDelay, shouldResetTimeout, onRetry } = currentState;\n    const delay = retryDelay(currentState.retryCount, error);\n    // Axios fails merging this configuration to the default configuration because it has an issue\n    // with circular structures: https://github.com/mzabriskie/axios/issues/370\n    fixConfig(axiosInstance, config);\n    if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {\n        const lastRequestDuration = Date.now() - currentState.lastRequestTime;\n        const timeout = config.timeout - lastRequestDuration - delay;\n        if (timeout <= 0) {\n            return Promise.reject(error);\n        }\n        config.timeout = timeout;\n    }\n    config.transformRequest = [(data) => data];\n    await onRetry(currentState.retryCount, error, config);\n    if (config.signal?.aborted) {\n        return Promise.resolve(axiosInstance(config));\n    }\n    return new Promise((resolve) => {\n        const abortListener = () => {\n            clearTimeout(timeout);\n            resolve(axiosInstance(config));\n        };\n        const timeout = setTimeout(() => {\n            resolve(axiosInstance(config));\n            if (config.signal?.removeEventListener) {\n                config.signal.removeEventListener('abort', abortListener);\n            }\n        }, delay);\n        if (config.signal?.addEventListener) {\n            config.signal.addEventListener('abort', abortListener, { once: true });\n        }\n    });\n}\nasync function handleMaxRetryTimesExceeded(currentState, error) {\n    if (currentState.retryCount >= currentState.retries)\n        await currentState.onMaxRetryTimesExceeded(error, currentState.retryCount);\n}\nconst axiosRetry = (axiosInstance, defaultOptions) => {\n    const requestInterceptorId = axiosInstance.interceptors.request.use((config) => {\n        setCurrentState(config, defaultOptions, true);\n        if (config[namespace]?.validateResponse) {\n            // by setting this, all HTTP responses will be go through the error interceptor first\n            config.validateStatus = () => false;\n        }\n        return config;\n    });\n    const responseInterceptorId = axiosInstance.interceptors.response.use(null, async (error) => {\n        const { config } = error;\n        // If we have no information to retry the request\n        if (!config) {\n            return Promise.reject(error);\n        }\n        const currentState = setCurrentState(config, defaultOptions);\n        if (error.response && currentState.validateResponse?.(error.response)) {\n            // no issue with response\n            return error.response;\n        }\n        if (await shouldRetry(currentState, error)) {\n            return handleRetry(axiosInstance, currentState, error, config);\n        }\n        await handleMaxRetryTimesExceeded(currentState, error);\n        return Promise.reject(error);\n    });\n    return { requestInterceptorId, responseInterceptorId };\n};\n// Compatibility with CommonJS\naxiosRetry.isNetworkError = isNetworkError;\naxiosRetry.isSafeRequestError = isSafeRequestError;\naxiosRetry.isIdempotentRequestError = isIdempotentRequestError;\naxiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;\naxiosRetry.exponentialDelay = exponentialDelay;\naxiosRetry.linearDelay = linearDelay;\naxiosRetry.isRetryableError = isRetryableError;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (axiosRetry);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXhpb3MtcmV0cnkvZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ3ZDO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZDQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLGFBQWEsVUFBVTtBQUN2QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQ0FBMEM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EscUVBQXFFLFlBQVk7QUFDakY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxVQUFVLEVBQUMiLCJzb3VyY2VzIjpbIkQ6XFxjb2RpbmdcXGxhdW5jaFxcdGhvdWdodFBvbGljZVxcbm9kZV9tb2R1bGVzXFxheGlvcy1yZXRyeVxcZGlzdFxcZXNtXFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaXNSZXRyeUFsbG93ZWQgZnJvbSAnaXMtcmV0cnktYWxsb3dlZCc7XG5leHBvcnQgY29uc3QgbmFtZXNwYWNlID0gJ2F4aW9zLXJldHJ5JztcbmV4cG9ydCBmdW5jdGlvbiBpc05ldHdvcmtFcnJvcihlcnJvcikge1xuICAgIGNvbnN0IENPREVfRVhDTFVERV9MSVNUID0gWydFUlJfQ0FOQ0VMRUQnLCAnRUNPTk5BQk9SVEVEJ107XG4gICAgaWYgKGVycm9yLnJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFlcnJvci5jb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gUHJldmVudHMgcmV0cnlpbmcgdGltZWQgb3V0ICYgY2FuY2VsbGVkIHJlcXVlc3RzXG4gICAgaWYgKENPREVfRVhDTFVERV9MSVNULmluY2x1ZGVzKGVycm9yLmNvZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gUHJldmVudHMgcmV0cnlpbmcgdW5zYWZlIGVycm9yc1xuICAgIHJldHVybiBpc1JldHJ5QWxsb3dlZChlcnJvcik7XG59XG5jb25zdCBTQUZFX0hUVFBfTUVUSE9EUyA9IFsnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddO1xuY29uc3QgSURFTVBPVEVOVF9IVFRQX01FVEhPRFMgPSBTQUZFX0hUVFBfTUVUSE9EUy5jb25jYXQoWydwdXQnLCAnZGVsZXRlJ10pO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUmV0cnlhYmxlRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gKGVycm9yLmNvZGUgIT09ICdFQ09OTkFCT1JURUQnICYmXG4gICAgICAgICghZXJyb3IucmVzcG9uc2UgfHxcbiAgICAgICAgICAgIGVycm9yLnJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5IHx8XG4gICAgICAgICAgICAoZXJyb3IucmVzcG9uc2Uuc3RhdHVzID49IDUwMCAmJiBlcnJvci5yZXNwb25zZS5zdGF0dXMgPD0gNTk5KSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU2FmZVJlcXVlc3RFcnJvcihlcnJvcikge1xuICAgIGlmICghZXJyb3IuY29uZmlnPy5tZXRob2QpIHtcbiAgICAgICAgLy8gQ2Fubm90IGRldGVybWluZSBpZiB0aGUgcmVxdWVzdCBjYW4gYmUgcmV0cmllZFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc1JldHJ5YWJsZUVycm9yKGVycm9yKSAmJiBTQUZFX0hUVFBfTUVUSE9EUy5pbmRleE9mKGVycm9yLmNvbmZpZy5tZXRob2QpICE9PSAtMTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0lkZW1wb3RlbnRSZXF1ZXN0RXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoIWVycm9yLmNvbmZpZz8ubWV0aG9kKSB7XG4gICAgICAgIC8vIENhbm5vdCBkZXRlcm1pbmUgaWYgdGhlIHJlcXVlc3QgY2FuIGJlIHJldHJpZWRcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNSZXRyeWFibGVFcnJvcihlcnJvcikgJiYgSURFTVBPVEVOVF9IVFRQX01FVEhPRFMuaW5kZXhPZihlcnJvci5jb25maWcubWV0aG9kKSAhPT0gLTE7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNOZXR3b3JrT3JJZGVtcG90ZW50UmVxdWVzdEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGlzTmV0d29ya0Vycm9yKGVycm9yKSB8fCBpc0lkZW1wb3RlbnRSZXF1ZXN0RXJyb3IoZXJyb3IpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJldHJ5QWZ0ZXIoZXJyb3IgPSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCByZXRyeUFmdGVySGVhZGVyID0gZXJyb3I/LnJlc3BvbnNlPy5oZWFkZXJzWydyZXRyeS1hZnRlciddO1xuICAgIGlmICghcmV0cnlBZnRlckhlYWRlcikge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLy8gaWYgdGhlIHJldHJ5IGFmdGVyIGhlYWRlciBpcyBhIG51bWJlciwgY29udmVydCBpdCB0byBtaWxsaXNlY29uZHNcbiAgICBsZXQgcmV0cnlBZnRlck1zID0gKE51bWJlcihyZXRyeUFmdGVySGVhZGVyKSB8fCAwKSAqIDEwMDA7XG4gICAgLy8gSWYgdGhlIHJldHJ5IGFmdGVyIGhlYWRlciBpcyBhIGRhdGUsIGdldCB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB1bnRpbCB0aGF0IGRhdGVcbiAgICBpZiAocmV0cnlBZnRlck1zID09PSAwKSB7XG4gICAgICAgIHJldHJ5QWZ0ZXJNcyA9IChuZXcgRGF0ZShyZXRyeUFmdGVySGVhZGVyKS52YWx1ZU9mKCkgfHwgMCkgLSBEYXRlLm5vdygpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgcmV0cnlBZnRlck1zKTtcbn1cbmZ1bmN0aW9uIG5vRGVsYXkoX3JldHJ5TnVtYmVyID0gMCwgZXJyb3IgPSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgcmV0cnlBZnRlcihlcnJvcikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4cG9uZW50aWFsRGVsYXkocmV0cnlOdW1iZXIgPSAwLCBlcnJvciA9IHVuZGVmaW5lZCwgZGVsYXlGYWN0b3IgPSAxMDApIHtcbiAgICBjb25zdCBjYWxjdWxhdGVkRGVsYXkgPSAyICoqIHJldHJ5TnVtYmVyICogZGVsYXlGYWN0b3I7XG4gICAgY29uc3QgZGVsYXkgPSBNYXRoLm1heChjYWxjdWxhdGVkRGVsYXksIHJldHJ5QWZ0ZXIoZXJyb3IpKTtcbiAgICBjb25zdCByYW5kb21TdW0gPSBkZWxheSAqIDAuMiAqIE1hdGgucmFuZG9tKCk7IC8vIDAtMjAlIG9mIHRoZSBkZWxheVxuICAgIHJldHVybiBkZWxheSArIHJhbmRvbVN1bTtcbn1cbi8qKlxuICogTGluZWFyIGRlbGF5XG4gKiBAcGFyYW0ge251bWJlciB8IHVuZGVmaW5lZH0gZGVsYXlGYWN0b3IgLSBkZWxheSBmYWN0b3IgaW4gbWlsbGlzZWNvbmRzIChkZWZhdWx0OiAxMDApXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IChyZXRyeU51bWJlcjogbnVtYmVyLCBlcnJvcjogQXhpb3NFcnJvciB8IHVuZGVmaW5lZCkgPT4gbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsaW5lYXJEZWxheShkZWxheUZhY3RvciA9IDEwMCkge1xuICAgIHJldHVybiAocmV0cnlOdW1iZXIgPSAwLCBlcnJvciA9IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICBjb25zdCBkZWxheSA9IHJldHJ5TnVtYmVyICogZGVsYXlGYWN0b3I7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChkZWxheSwgcmV0cnlBZnRlcihlcnJvcikpO1xuICAgIH07XG59XG5leHBvcnQgY29uc3QgREVGQVVMVF9PUFRJT05TID0ge1xuICAgIHJldHJpZXM6IDMsXG4gICAgcmV0cnlDb25kaXRpb246IGlzTmV0d29ya09ySWRlbXBvdGVudFJlcXVlc3RFcnJvcixcbiAgICByZXRyeURlbGF5OiBub0RlbGF5LFxuICAgIHNob3VsZFJlc2V0VGltZW91dDogZmFsc2UsXG4gICAgb25SZXRyeTogKCkgPT4geyB9LFxuICAgIG9uTWF4UmV0cnlUaW1lc0V4Y2VlZGVkOiAoKSA9PiB7IH0sXG4gICAgdmFsaWRhdGVSZXNwb25zZTogbnVsbFxufTtcbmZ1bmN0aW9uIGdldFJlcXVlc3RPcHRpb25zKGNvbmZpZywgZGVmYXVsdE9wdGlvbnMpIHtcbiAgICByZXR1cm4geyAuLi5ERUZBVUxUX09QVElPTlMsIC4uLmRlZmF1bHRPcHRpb25zLCAuLi5jb25maWdbbmFtZXNwYWNlXSB9O1xufVxuZnVuY3Rpb24gc2V0Q3VycmVudFN0YXRlKGNvbmZpZywgZGVmYXVsdE9wdGlvbnMsIHJlc2V0TGFzdFJlcXVlc3RUaW1lID0gZmFsc2UpIHtcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBnZXRSZXF1ZXN0T3B0aW9ucyhjb25maWcsIGRlZmF1bHRPcHRpb25zIHx8IHt9KTtcbiAgICBjdXJyZW50U3RhdGUucmV0cnlDb3VudCA9IGN1cnJlbnRTdGF0ZS5yZXRyeUNvdW50IHx8IDA7XG4gICAgaWYgKCFjdXJyZW50U3RhdGUubGFzdFJlcXVlc3RUaW1lIHx8IHJlc2V0TGFzdFJlcXVlc3RUaW1lKSB7XG4gICAgICAgIGN1cnJlbnRTdGF0ZS5sYXN0UmVxdWVzdFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgICBjb25maWdbbmFtZXNwYWNlXSA9IGN1cnJlbnRTdGF0ZTtcbiAgICByZXR1cm4gY3VycmVudFN0YXRlO1xufVxuZnVuY3Rpb24gZml4Q29uZmlnKGF4aW9zSW5zdGFuY2UsIGNvbmZpZykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoYXhpb3NJbnN0YW5jZS5kZWZhdWx0cy5hZ2VudCA9PT0gY29uZmlnLmFnZW50KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5hZ2VudDtcbiAgICB9XG4gICAgaWYgKGF4aW9zSW5zdGFuY2UuZGVmYXVsdHMuaHR0cEFnZW50ID09PSBjb25maWcuaHR0cEFnZW50KSB7XG4gICAgICAgIGRlbGV0ZSBjb25maWcuaHR0cEFnZW50O1xuICAgIH1cbiAgICBpZiAoYXhpb3NJbnN0YW5jZS5kZWZhdWx0cy5odHRwc0FnZW50ID09PSBjb25maWcuaHR0cHNBZ2VudCkge1xuICAgICAgICBkZWxldGUgY29uZmlnLmh0dHBzQWdlbnQ7XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gc2hvdWxkUmV0cnkoY3VycmVudFN0YXRlLCBlcnJvcikge1xuICAgIGNvbnN0IHsgcmV0cmllcywgcmV0cnlDb25kaXRpb24gfSA9IGN1cnJlbnRTdGF0ZTtcbiAgICBjb25zdCBzaG91bGRSZXRyeU9yUHJvbWlzZSA9IChjdXJyZW50U3RhdGUucmV0cnlDb3VudCB8fCAwKSA8IHJldHJpZXMgJiYgcmV0cnlDb25kaXRpb24oZXJyb3IpO1xuICAgIC8vIFRoaXMgY291bGQgYmUgYSBwcm9taXNlXG4gICAgaWYgKHR5cGVvZiBzaG91bGRSZXRyeU9yUHJvbWlzZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFJldHJ5UHJvbWlzZVJlc3VsdCA9IGF3YWl0IHNob3VsZFJldHJ5T3JQcm9taXNlO1xuICAgICAgICAgICAgLy8ga2VlcCByZXR1cm4gdHJ1ZSB1bmxlc3Mgc2hvdWxkUmV0cnlQcm9taXNlUmVzdWx0IHJldHVybiBmYWxzZSBmb3IgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgcmV0dXJuIHNob3VsZFJldHJ5UHJvbWlzZVJlc3VsdCAhPT0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkUmV0cnlPclByb21pc2U7XG59XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVSZXRyeShheGlvc0luc3RhbmNlLCBjdXJyZW50U3RhdGUsIGVycm9yLCBjb25maWcpIHtcbiAgICBjdXJyZW50U3RhdGUucmV0cnlDb3VudCArPSAxO1xuICAgIGNvbnN0IHsgcmV0cnlEZWxheSwgc2hvdWxkUmVzZXRUaW1lb3V0LCBvblJldHJ5IH0gPSBjdXJyZW50U3RhdGU7XG4gICAgY29uc3QgZGVsYXkgPSByZXRyeURlbGF5KGN1cnJlbnRTdGF0ZS5yZXRyeUNvdW50LCBlcnJvcik7XG4gICAgLy8gQXhpb3MgZmFpbHMgbWVyZ2luZyB0aGlzIGNvbmZpZ3VyYXRpb24gdG8gdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBiZWNhdXNlIGl0IGhhcyBhbiBpc3N1ZVxuICAgIC8vIHdpdGggY2lyY3VsYXIgc3RydWN0dXJlczogaHR0cHM6Ly9naXRodWIuY29tL216YWJyaXNraWUvYXhpb3MvaXNzdWVzLzM3MFxuICAgIGZpeENvbmZpZyhheGlvc0luc3RhbmNlLCBjb25maWcpO1xuICAgIGlmICghc2hvdWxkUmVzZXRUaW1lb3V0ICYmIGNvbmZpZy50aW1lb3V0ICYmIGN1cnJlbnRTdGF0ZS5sYXN0UmVxdWVzdFRpbWUpIHtcbiAgICAgICAgY29uc3QgbGFzdFJlcXVlc3REdXJhdGlvbiA9IERhdGUubm93KCkgLSBjdXJyZW50U3RhdGUubGFzdFJlcXVlc3RUaW1lO1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQgLSBsYXN0UmVxdWVzdER1cmF0aW9uIC0gZGVsYXk7XG4gICAgICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLnRpbWVvdXQgPSB0aW1lb3V0O1xuICAgIH1cbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdCA9IFsoZGF0YSkgPT4gZGF0YV07XG4gICAgYXdhaXQgb25SZXRyeShjdXJyZW50U3RhdGUucmV0cnlDb3VudCwgZXJyb3IsIGNvbmZpZyk7XG4gICAgaWYgKGNvbmZpZy5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShheGlvc0luc3RhbmNlKGNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgY29uc3QgYWJvcnRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHJlc29sdmUoYXhpb3NJbnN0YW5jZShjb25maWcpKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShheGlvc0luc3RhbmNlKGNvbmZpZykpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5zaWduYWw/LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRMaXN0ZW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICAgICAgaWYgKGNvbmZpZy5zaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydExpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZU1heFJldHJ5VGltZXNFeGNlZWRlZChjdXJyZW50U3RhdGUsIGVycm9yKSB7XG4gICAgaWYgKGN1cnJlbnRTdGF0ZS5yZXRyeUNvdW50ID49IGN1cnJlbnRTdGF0ZS5yZXRyaWVzKVxuICAgICAgICBhd2FpdCBjdXJyZW50U3RhdGUub25NYXhSZXRyeVRpbWVzRXhjZWVkZWQoZXJyb3IsIGN1cnJlbnRTdGF0ZS5yZXRyeUNvdW50KTtcbn1cbmNvbnN0IGF4aW9zUmV0cnkgPSAoYXhpb3NJbnN0YW5jZSwgZGVmYXVsdE9wdGlvbnMpID0+IHtcbiAgICBjb25zdCByZXF1ZXN0SW50ZXJjZXB0b3JJZCA9IGF4aW9zSW5zdGFuY2UuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKChjb25maWcpID0+IHtcbiAgICAgICAgc2V0Q3VycmVudFN0YXRlKGNvbmZpZywgZGVmYXVsdE9wdGlvbnMsIHRydWUpO1xuICAgICAgICBpZiAoY29uZmlnW25hbWVzcGFjZV0/LnZhbGlkYXRlUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIC8vIGJ5IHNldHRpbmcgdGhpcywgYWxsIEhUVFAgcmVzcG9uc2VzIHdpbGwgYmUgZ28gdGhyb3VnaCB0aGUgZXJyb3IgaW50ZXJjZXB0b3IgZmlyc3RcbiAgICAgICAgICAgIGNvbmZpZy52YWxpZGF0ZVN0YXR1cyA9ICgpID0+IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25maWc7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2VJbnRlcmNlcHRvcklkID0gYXhpb3NJbnN0YW5jZS5pbnRlcmNlcHRvcnMucmVzcG9uc2UudXNlKG51bGwsIGFzeW5jIChlcnJvcikgPT4ge1xuICAgICAgICBjb25zdCB7IGNvbmZpZyB9ID0gZXJyb3I7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgbm8gaW5mb3JtYXRpb24gdG8gcmV0cnkgdGhlIHJlcXVlc3RcbiAgICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gc2V0Q3VycmVudFN0YXRlKGNvbmZpZywgZGVmYXVsdE9wdGlvbnMpO1xuICAgICAgICBpZiAoZXJyb3IucmVzcG9uc2UgJiYgY3VycmVudFN0YXRlLnZhbGlkYXRlUmVzcG9uc2U/LihlcnJvci5yZXNwb25zZSkpIHtcbiAgICAgICAgICAgIC8vIG5vIGlzc3VlIHdpdGggcmVzcG9uc2VcbiAgICAgICAgICAgIHJldHVybiBlcnJvci5yZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXdhaXQgc2hvdWxkUmV0cnkoY3VycmVudFN0YXRlLCBlcnJvcikpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVSZXRyeShheGlvc0luc3RhbmNlLCBjdXJyZW50U3RhdGUsIGVycm9yLCBjb25maWcpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGhhbmRsZU1heFJldHJ5VGltZXNFeGNlZWRlZChjdXJyZW50U3RhdGUsIGVycm9yKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9KTtcbiAgICByZXR1cm4geyByZXF1ZXN0SW50ZXJjZXB0b3JJZCwgcmVzcG9uc2VJbnRlcmNlcHRvcklkIH07XG59O1xuLy8gQ29tcGF0aWJpbGl0eSB3aXRoIENvbW1vbkpTXG5heGlvc1JldHJ5LmlzTmV0d29ya0Vycm9yID0gaXNOZXR3b3JrRXJyb3I7XG5heGlvc1JldHJ5LmlzU2FmZVJlcXVlc3RFcnJvciA9IGlzU2FmZVJlcXVlc3RFcnJvcjtcbmF4aW9zUmV0cnkuaXNJZGVtcG90ZW50UmVxdWVzdEVycm9yID0gaXNJZGVtcG90ZW50UmVxdWVzdEVycm9yO1xuYXhpb3NSZXRyeS5pc05ldHdvcmtPcklkZW1wb3RlbnRSZXF1ZXN0RXJyb3IgPSBpc05ldHdvcmtPcklkZW1wb3RlbnRSZXF1ZXN0RXJyb3I7XG5heGlvc1JldHJ5LmV4cG9uZW50aWFsRGVsYXkgPSBleHBvbmVudGlhbERlbGF5O1xuYXhpb3NSZXRyeS5saW5lYXJEZWxheSA9IGxpbmVhckRlbGF5O1xuYXhpb3NSZXRyeS5pc1JldHJ5YWJsZUVycm9yID0gaXNSZXRyeWFibGVFcnJvcjtcbmV4cG9ydCBkZWZhdWx0IGF4aW9zUmV0cnk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/axios-retry/dist/esm/index.js\n");

/***/ })

};
;