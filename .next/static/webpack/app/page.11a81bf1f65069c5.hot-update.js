"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/services/analysisService.ts":
/*!*********************************************!*\
  !*** ./src/lib/services/analysisService.ts ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnalysisService: () => (/* binding */ AnalysisService),\n/* harmony export */   analysisService: () => (/* binding */ analysisService)\n/* harmony export */ });\n/* harmony import */ var _redditApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./redditApi */ \"(app-pages-browser)/./src/lib/services/redditApi.ts\");\n/* harmony import */ var _multiModelPipeline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./multiModelPipeline */ \"(app-pages-browser)/./src/lib/services/multiModelPipeline.ts\");\n/* harmony import */ var _cacheService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cacheService */ \"(app-pages-browser)/./src/lib/services/cacheService.ts\");\n/* harmony import */ var _tokenBudget__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tokenBudget */ \"(app-pages-browser)/./src/lib/services/tokenBudget.ts\");\n\n\n\n\nclass AnalysisService {\n    setVerbose(verbose) {\n        this.verbose = verbose;\n        _redditApi__WEBPACK_IMPORTED_MODULE_0__.redditApi.setVerbose(verbose);\n        _multiModelPipeline__WEBPACK_IMPORTED_MODULE_1__.multiModelPipeline.setVerbose(verbose);\n    }\n    debug() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (this.verbose) {\n            console.log('[AnalysisService]', ...args);\n        }\n    }\n    async analyzeUser(username) {\n        let analyzerUserId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '1';\n        try {\n            // Validate username\n            if (!username || username.trim().length === 0) {\n                throw new Error('Username is required');\n            }\n            const cleanUsername = username.trim().replace(/^u\\//, '');\n            this.debug(\"Starting comprehensive analysis for \".concat(cleanUsername));\n            // Check budget status\n            const budgetStatus = _tokenBudget__WEBPACK_IMPORTED_MODULE_3__.tokenBudget.getBudgetStatus();\n            this.debug('Budget status:', budgetStatus);\n            if (budgetStatus.isWarning) {\n                console.warn(\"Budget warning: \".concat(budgetStatus.percentage.toFixed(1), \"% used\"));\n            }\n            // Check cache first with content validation\n            const userData = await _redditApi__WEBPACK_IMPORTED_MODULE_0__.redditApi.getFullUserData(cleanUsername, {\n                maxItems: 5000,\n                maxAge: 365,\n                verbose: this.verbose\n            });\n            if (!userData.user) {\n                throw new Error('User not found on Reddit');\n            }\n            // Check if user has enough content\n            if (userData.comments.length === 0 && userData.posts.length === 0) {\n                throw new Error('User has no public comments or posts to analyze');\n            }\n            this.debug(\"Comprehensive data fetched for \".concat(cleanUsername, \":\"), {\n                comments: userData.comments.length,\n                posts: userData.posts.length,\n                totalContent: userData.comments.length + userData.posts.length,\n                userKarma: userData.user.total_karma,\n                accountAge: Math.floor((Date.now() / 1000 - userData.user.created_utc) / (24 * 60 * 60))\n            });\n            // Check cache with content validation\n            if (_cacheService__WEBPACK_IMPORTED_MODULE_2__.cacheService.hasValidAnalysis(cleanUsername, userData.comments, userData.posts)) {\n                this.debug(\"Using cached analysis for \".concat(cleanUsername));\n                const cachedReport = _cacheService__WEBPACK_IMPORTED_MODULE_2__.cacheService.getAnalysis(cleanUsername, userData.comments, userData.posts);\n                return {\n                    id: \"analysis-cached-\".concat(Date.now(), \"-\").concat(cleanUsername),\n                    targetUsername: cleanUsername,\n                    analyzerUserId,\n                    contradictionsFound: cachedReport.contradictions.length,\n                    confidenceScore: this.calculateWeightedConfidence(cachedReport.contradictions),\n                    analysisDate: new Date().toISOString(),\n                    reportData: cachedReport,\n                    status: 'completed'\n                };\n            }\n            // Perform optimized pipeline analysis\n            this.debug(\"Starting optimized pipeline analysis for \".concat(cleanUsername));\n            try {\n                const reportData = await _multiModelPipeline__WEBPACK_IMPORTED_MODULE_1__.multiModelPipeline.analyzeUser(userData.comments, userData.posts, cleanUsername);\n                this.debug('AI analysis result:', reportData);\n                // Create analysis result with weighted confidence\n                const analysis = {\n                    id: \"analysis-\".concat(Date.now(), \"-\").concat(cleanUsername),\n                    targetUsername: cleanUsername,\n                    analyzerUserId,\n                    contradictionsFound: reportData.contradictions.length,\n                    confidenceScore: this.calculateWeightedConfidence(reportData.contradictions),\n                    analysisDate: new Date().toISOString(),\n                    reportData,\n                    status: 'completed'\n                };\n                this.debug(\"Analysis complete for \".concat(cleanUsername, \":\"), {\n                    contradictionsFound: analysis.contradictionsFound,\n                    weightedConfidence: analysis.confidenceScore,\n                    totalItemsAnalyzed: userData.comments.length + userData.posts.length,\n                    budgetUsed: _tokenBudget__WEBPACK_IMPORTED_MODULE_3__.tokenBudget.getBudgetStatus().spent.toFixed(4)\n                });\n                return analysis;\n            } catch (aiError) {\n                this.debug('AI analysis failed:', aiError);\n                throw aiError;\n            }\n        } catch (error) {\n            this.debug('Analysis failed:', error);\n            // Return failed analysis with error info\n            return {\n                id: \"analysis-failed-\".concat(Date.now()),\n                targetUsername: username,\n                analyzerUserId,\n                contradictionsFound: 0,\n                confidenceScore: 0,\n                analysisDate: new Date().toISOString(),\n                reportData: {\n                    summary: \"Analysis failed: \".concat(error instanceof Error ? error.message : 'Unknown error occurred'),\n                    contradictions: [],\n                    timeline: [],\n                    stats: {\n                        totalComments: 0,\n                        timespan: '0 days',\n                        topSubreddits: [],\n                        sentimentTrend: 0\n                    }\n                },\n                status: 'failed'\n            };\n        }\n    }\n    calculateWeightedConfidence(contradictions) {\n        if (contradictions.length === 0) return 0;\n        // Weight by recency and verification status\n        let totalWeight = 0;\n        let weightedSum = 0;\n        for (const contradiction of contradictions){\n            let weight = 1;\n            // Higher weight for verified contradictions\n            if (contradiction.verified) {\n                weight *= 1.5;\n            }\n            // Higher weight for recent contradictions\n            const dates = contradiction.dates.map((d)=>new Date(d).getTime());\n            const avgDate = (dates[0] + dates[1]) / 2;\n            const ageInDays = (Date.now() - avgDate) / (24 * 60 * 60 * 1000);\n            if (ageInDays < 30) {\n                weight *= 1.3; // Recent contradictions are more significant\n            } else if (ageInDays > 365) {\n                weight *= 0.8; // Older contradictions less significant\n            }\n            // Weight by confidence score\n            weight *= contradiction.confidenceScore / 100;\n            weightedSum += contradiction.confidenceScore * weight;\n            totalWeight += weight;\n        }\n        return Math.round(weightedSum / totalWeight);\n    }\n    async validateUsername(username) {\n        try {\n            const cleanUsername = username.trim().replace(/^u\\//, '');\n            await _redditApi__WEBPACK_IMPORTED_MODULE_0__.redditApi.getUserInfo(cleanUsername);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    async getUserPreview(username) {\n        try {\n            const cleanUsername = username.trim().replace(/^u\\//, '');\n            return await _redditApi__WEBPACK_IMPORTED_MODULE_0__.redditApi.getUserPreview(cleanUsername);\n        } catch (e) {\n            return {\n                exists: false,\n                karma: 0,\n                accountAge: 'Unknown',\n                recentActivity: false,\n                estimatedComments: 0\n            };\n        }\n    }\n    // Enhanced cache management\n    clearUserCache(username) {\n        const cleanUsername = username.trim().replace(/^u\\//, '');\n        _cacheService__WEBPACK_IMPORTED_MODULE_2__.cacheService.clearAnalysis(cleanUsername);\n    }\n    getCacheStats() {\n        return _cacheService__WEBPACK_IMPORTED_MODULE_2__.cacheService.getStats();\n    }\n    getBudgetStats() {\n        return {\n            budget: _tokenBudget__WEBPACK_IMPORTED_MODULE_3__.tokenBudget.getBudgetStatus(),\n            usage: _tokenBudget__WEBPACK_IMPORTED_MODULE_3__.tokenBudget.getUsageStats()\n        };\n    }\n    resetBudget() {\n        _tokenBudget__WEBPACK_IMPORTED_MODULE_3__.tokenBudget.resetBudget();\n    }\n    setBudget(maxDollar) {\n        let warningThreshold = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 80;\n        _tokenBudget__WEBPACK_IMPORTED_MODULE_3__.tokenBudget.setBudget({\n            maxDollar,\n            warningThreshold\n        });\n    }\n    // Debug and monitoring methods\n    getDebugInfo() {\n        return {\n            cache: _cacheService__WEBPACK_IMPORTED_MODULE_2__.cacheService.getDebugInfo(),\n            budget: this.getBudgetStats(),\n            verbose: this.verbose\n        };\n    }\n    // Streaming analysis for large datasets\n    async *analyzeUserStream(username) {\n        const cleanUsername = username.trim().replace(/^u\\//, '');\n        yield {\n            stage: 'validation',\n            progress: 0\n        };\n        try {\n            // Validate user\n            const user = await _redditApi__WEBPACK_IMPORTED_MODULE_0__.redditApi.getUserInfo(cleanUsername);\n            yield {\n                stage: 'validation',\n                progress: 100,\n                data: {\n                    user\n                }\n            };\n            // Stream comments\n            yield {\n                stage: 'fetching',\n                progress: 0\n            };\n            const comments = [];\n            const posts = [];\n            let fetchProgress = 0;\n            for await (const batch of _redditApi__WEBPACK_IMPORTED_MODULE_0__.redditApi.iterateComments(cleanUsername, {\n                maxItems: 5000\n            })){\n                comments.push(...batch);\n                fetchProgress += 10;\n                yield {\n                    stage: 'fetching',\n                    progress: Math.min(fetchProgress, 80)\n                };\n            }\n            // Stream posts\n            for await (const batch of _redditApi__WEBPACK_IMPORTED_MODULE_0__.redditApi.iteratePosts(cleanUsername, {\n                maxItems: 1000\n            })){\n                posts.push(...batch);\n                fetchProgress += 5;\n                yield {\n                    stage: 'fetching',\n                    progress: Math.min(fetchProgress, 100)\n                };\n            }\n            yield {\n                stage: 'fetching',\n                progress: 100,\n                data: {\n                    comments: comments.length,\n                    posts: posts.length\n                }\n            };\n            // Analysis\n            yield {\n                stage: 'analyzing',\n                progress: 0\n            };\n            const reportData = await _multiModelPipeline__WEBPACK_IMPORTED_MODULE_1__.multiModelPipeline.analyzeUser(comments, posts, cleanUsername);\n            yield {\n                stage: 'analyzing',\n                progress: 100,\n                data: reportData\n            };\n            // Complete\n            yield {\n                stage: 'complete',\n                progress: 100,\n                data: reportData\n            };\n        } catch (error) {\n            yield {\n                stage: 'error',\n                progress: 0,\n                data: {\n                    error: error instanceof Error ? error.message : 'Unknown error'\n                }\n            };\n        }\n    }\n    constructor(){\n        this.verbose = false;\n    }\n}\nconst analysisService = new AnalysisService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2VydmljZXMvYW5hbHlzaXNTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF3QztBQUNrQjtBQUNaO0FBQ0Y7QUFHckMsTUFBTUk7SUFHWEMsV0FBV0MsT0FBZ0IsRUFBRTtRQUMzQixJQUFJLENBQUNBLE9BQU8sR0FBR0E7UUFDZk4saURBQVNBLENBQUNLLFVBQVUsQ0FBQ0M7UUFDckJMLG1FQUFrQkEsQ0FBQ0ksVUFBVSxDQUFDQztJQUNoQztJQUVRQyxRQUFzQjtRQUFoQjtZQUFHQyxLQUFILHVCQUFjOztRQUMxQixJQUFJLElBQUksQ0FBQ0YsT0FBTyxFQUFFO1lBQ2hCRyxRQUFRQyxHQUFHLENBQUMsd0JBQXdCRjtRQUN0QztJQUNGO0lBRUEsTUFBTUcsWUFBWUMsUUFBZ0IsRUFBbUQ7WUFBakRDLGlCQUFBQSxpRUFBeUI7UUFDM0QsSUFBSTtZQUNGLG9CQUFvQjtZQUNwQixJQUFJLENBQUNELFlBQVlBLFNBQVNFLElBQUksR0FBR0MsTUFBTSxLQUFLLEdBQUc7Z0JBQzdDLE1BQU0sSUFBSUMsTUFBTTtZQUNsQjtZQUVBLE1BQU1DLGdCQUFnQkwsU0FBU0UsSUFBSSxHQUFHSSxPQUFPLENBQUMsUUFBUTtZQUN0RCxJQUFJLENBQUNYLEtBQUssQ0FBQyx1Q0FBcUQsT0FBZFU7WUFFbEQsc0JBQXNCO1lBQ3RCLE1BQU1FLGVBQWVoQixxREFBV0EsQ0FBQ2lCLGVBQWU7WUFDaEQsSUFBSSxDQUFDYixLQUFLLENBQUMsa0JBQWtCWTtZQUU3QixJQUFJQSxhQUFhRSxTQUFTLEVBQUU7Z0JBQzFCWixRQUFRYSxJQUFJLENBQUMsbUJBQXNELE9BQW5DSCxhQUFhSSxVQUFVLENBQUNDLE9BQU8sQ0FBQyxJQUFHO1lBQ3JFO1lBRUEsNENBQTRDO1lBQzVDLE1BQU1DLFdBQVcsTUFBTXpCLGlEQUFTQSxDQUFDMEIsZUFBZSxDQUFDVCxlQUFlO2dCQUM5RFUsVUFBVTtnQkFDVkMsUUFBUTtnQkFDUnRC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QU1DLFNBQVMzRyxpREFBU0EsQ0FBQytHLFlBQVksQ0FBQzlGLGVBQWU7Z0JBQUVVLFVBQVU7WUFBSyxHQUFJO2dCQUNuRkksTUFBTThFLElBQUksSUFBSUY7Z0JBQ2RELGlCQUFpQjtnQkFDakIsTUFBTTtvQkFBRUgsT0FBTztvQkFBWUMsVUFBVXBFLEtBQUswRSxHQUFHLENBQUNKLGVBQWU7Z0JBQUs7WUFDcEU7WUFFQSxNQUFNO2dCQUFFSCxPQUFPO2dCQUFZQyxVQUFVO2dCQUFLQyxNQUFNO29CQUFFM0UsVUFBVUEsU0FBU2YsTUFBTTtvQkFBRWdCLE9BQU9BLE1BQU1oQixNQUFNO2dCQUFDO1lBQUU7WUFFbkcsV0FBVztZQUNYLE1BQU07Z0JBQUV3RixPQUFPO2dCQUFhQyxVQUFVO1lBQUU7WUFDeEMsTUFBTXBELGFBQWEsTUFBTW5ELG1FQUFrQkEsQ0FBQ1UsV0FBVyxDQUFDbUIsVUFBVUMsT0FBT2Q7WUFDekUsTUFBTTtnQkFBRXNGLE9BQU87Z0JBQWFDLFVBQVU7Z0JBQUtDLE1BQU1yRDtZQUFXO1lBRTVELFdBQVc7WUFDWCxNQUFNO2dCQUFFbUQsT0FBTztnQkFBWUMsVUFBVTtnQkFBS0MsTUFBTXJEO1lBQVc7UUFFN0QsRUFBRSxPQUFPUSxPQUFPO1lBQ2QsTUFBTTtnQkFBRTJDLE9BQU87Z0JBQVNDLFVBQVU7Z0JBQUdDLE1BQU07b0JBQUU3QyxPQUFPQSxpQkFBaUI1QyxRQUFRNEMsTUFBTUUsT0FBTyxHQUFHO2dCQUFnQjtZQUFFO1FBQ2pIO0lBQ0Y7O2FBM1JReEQsVUFBVTs7QUE0UnBCO0FBRU8sTUFBTTBHLGtCQUFrQixJQUFJNUcsa0JBQWtCIiwic291cmNlcyI6WyJEOlxcY29kaW5nXFxsYXVuY2hcXHRob3VnaHRQb2xpY2VcXHNyY1xcbGliXFxzZXJ2aWNlc1xcYW5hbHlzaXNTZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlZGRpdEFwaSB9IGZyb20gJy4vcmVkZGl0QXBpJztcclxuaW1wb3J0IHsgbXVsdGlNb2RlbFBpcGVsaW5lIH0gZnJvbSAnLi9tdWx0aU1vZGVsUGlwZWxpbmUnO1xyXG5pbXBvcnQgeyBjYWNoZVNlcnZpY2UgfSBmcm9tICcuL2NhY2hlU2VydmljZSc7XHJcbmltcG9ydCB7IHRva2VuQnVkZ2V0IH0gZnJvbSAnLi90b2tlbkJ1ZGdldCc7XHJcbmltcG9ydCB7IEFuYWx5c2lzIH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEFuYWx5c2lzU2VydmljZSB7XHJcbiAgcHJpdmF0ZSB2ZXJib3NlID0gZmFsc2U7XHJcblxyXG4gIHNldFZlcmJvc2UodmVyYm9zZTogYm9vbGVhbikge1xyXG4gICAgdGhpcy52ZXJib3NlID0gdmVyYm9zZTtcclxuICAgIHJlZGRpdEFwaS5zZXRWZXJib3NlKHZlcmJvc2UpO1xyXG4gICAgbXVsdGlNb2RlbFBpcGVsaW5lLnNldFZlcmJvc2UodmVyYm9zZSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGRlYnVnKC4uLmFyZ3M6IGFueVtdKSB7XHJcbiAgICBpZiAodGhpcy52ZXJib3NlKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdbQW5hbHlzaXNTZXJ2aWNlXScsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgYW5hbHl6ZVVzZXIodXNlcm5hbWU6IHN0cmluZywgYW5hbHl6ZXJVc2VySWQ6IHN0cmluZyA9ICcxJyk6IFByb21pc2U8QW5hbHlzaXM+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFZhbGlkYXRlIHVzZXJuYW1lXHJcbiAgICAgIGlmICghdXNlcm5hbWUgfHwgdXNlcm5hbWUudHJpbSgpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVXNlcm5hbWUgaXMgcmVxdWlyZWQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgY2xlYW5Vc2VybmFtZSA9IHVzZXJuYW1lLnRyaW0oKS5yZXBsYWNlKC9edVxcLy8sICcnKTtcclxuICAgICAgdGhpcy5kZWJ1ZyhgU3RhcnRpbmcgY29tcHJlaGVuc2l2ZSBhbmFseXNpcyBmb3IgJHtjbGVhblVzZXJuYW1lfWApO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgYnVkZ2V0IHN0YXR1c1xyXG4gICAgICBjb25zdCBidWRnZXRTdGF0dXMgPSB0b2tlbkJ1ZGdldC5nZXRCdWRnZXRTdGF0dXMoKTtcclxuICAgICAgdGhpcy5kZWJ1ZygnQnVkZ2V0IHN0YXR1czonLCBidWRnZXRTdGF0dXMpO1xyXG5cclxuICAgICAgaWYgKGJ1ZGdldFN0YXR1cy5pc1dhcm5pbmcpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYEJ1ZGdldCB3YXJuaW5nOiAke2J1ZGdldFN0YXR1cy5wZXJjZW50YWdlLnRvRml4ZWQoMSl9JSB1c2VkYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0IHdpdGggY29udGVudCB2YWxpZGF0aW9uXHJcbiAgICAgIGNvbnN0IHVzZXJEYXRhID0gYXdhaXQgcmVkZGl0QXBpLmdldEZ1bGxVc2VyRGF0YShjbGVhblVzZXJuYW1lLCB7XHJcbiAgICAgICAgbWF4SXRlbXM6IDUwMDAsXHJcbiAgICAgICAgbWF4QWdlOiAzNjUsXHJcbiAgICAgICAgdmVyYm9zZTogdGhpcy52ZXJib3NlXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKCF1c2VyRGF0YS51c2VyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVc2VyIG5vdCBmb3VuZCBvbiBSZWRkaXQnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgaWYgdXNlciBoYXMgZW5vdWdoIGNvbnRlbnRcclxuICAgICAgaWYgKHVzZXJEYXRhLmNvbW1lbnRzLmxlbmd0aCA9PT0gMCAmJiB1c2VyRGF0YS5wb3N0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgaGFzIG5vIHB1YmxpYyBjb21tZW50cyBvciBwb3N0cyB0byBhbmFseXplJyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZGVidWcoYENvbXByZWhlbnNpdmUgZGF0YSBmZXRjaGVkIGZvciAke2NsZWFuVXNlcm5hbWV9OmAsIHtcclxuICAgICAgICBjb21tZW50czogdXNlckRhdGEuY29tbWVudHMubGVuZ3RoLFxyXG4gICAgICAgIHBvc3RzOiB1c2VyRGF0YS5wb3N0cy5sZW5ndGgsXHJcbiAgICAgICAgdG90YWxDb250ZW50OiB1c2VyRGF0YS5jb21tZW50cy5sZW5ndGggKyB1c2VyRGF0YS5wb3N0cy5sZW5ndGgsXHJcbiAgICAgICAgdXNlckthcm1hOiB1c2VyRGF0YS51c2VyLnRvdGFsX2thcm1hLFxyXG4gICAgICAgIGFjY291bnRBZ2U6IE1hdGguZmxvb3IoKERhdGUubm93KCkgLyAxMDAwIC0gdXNlckRhdGEudXNlci5jcmVhdGVkX3V0YykgLyAoMjQgKiA2MCAqIDYwKSlcclxuICAgICAgfSk7XHJcblxyXG4gICAgICAvLyBDaGVjayBjYWNoZSB3aXRoIGNvbnRlbnQgdmFsaWRhdGlvblxyXG4gICAgICBpZiAoY2FjaGVTZXJ2aWNlLmhhc1ZhbGlkQW5hbHlzaXMoY2xlYW5Vc2VybmFtZSwgdXNlckRhdGEuY29tbWVudHMsIHVzZXJEYXRhLnBvc3RzKSkge1xyXG4gICAgICAgIHRoaXMuZGVidWcoYFVzaW5nIGNhY2hlZCBhbmFseXNpcyBmb3IgJHtjbGVhblVzZXJuYW1lfWApO1xyXG4gICAgICAgIGNvbnN0IGNhY2hlZFJlcG9ydCA9IGNhY2hlU2VydmljZS5nZXRBbmFseXNpcyhjbGVhblVzZXJuYW1lLCB1c2VyRGF0YS5jb21tZW50cywgdXNlckRhdGEucG9zdHMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBpZDogYGFuYWx5c2lzLWNhY2hlZC0ke0RhdGUubm93KCl9LSR7Y2xlYW5Vc2VybmFtZX1gLFxyXG4gICAgICAgICAgdGFyZ2V0VXNlcm5hbWU6IGNsZWFuVXNlcm5hbWUsXHJcbiAgICAgICAgICBhbmFseXplclVzZXJJZCxcclxuICAgICAgICAgIGNvbnRyYWRpY3Rpb25zRm91bmQ6IGNhY2hlZFJlcG9ydC5jb250cmFkaWN0aW9ucy5sZW5ndGgsXHJcbiAgICAgICAgICBjb25maWRlbmNlU2NvcmU6IHRoaXMuY2FsY3VsYXRlV2VpZ2h0ZWRDb25maWRlbmNlKGNhY2hlZFJlcG9ydC5jb250cmFkaWN0aW9ucyksXHJcbiAgICAgICAgICBhbmFseXNpc0RhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgIHJlcG9ydERhdGE6IGNhY2hlZFJlcG9ydCxcclxuICAgICAgICAgIHN0YXR1czogJ2NvbXBsZXRlZCdcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQZXJmb3JtIG9wdGltaXplZCBwaXBlbGluZSBhbmFseXNpc1xyXG4gICAgICB0aGlzLmRlYnVnKGBTdGFydGluZyBvcHRpbWl6ZWQgcGlwZWxpbmUgYW5hbHlzaXMgZm9yICR7Y2xlYW5Vc2VybmFtZX1gKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBjb25zdCByZXBvcnREYXRhID0gYXdhaXQgbXVsdGlNb2RlbFBpcGVsaW5lLmFuYWx5emVVc2VyKFxyXG4gICAgICAgICAgdXNlckRhdGEuY29tbWVudHMsIFxyXG4gICAgICAgICAgdXNlckRhdGEucG9zdHMsIFxyXG4gICAgICAgICAgY2xlYW5Vc2VybmFtZVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5kZWJ1ZygnQUkgYW5hbHlzaXMgcmVzdWx0OicsIHJlcG9ydERhdGEpO1xyXG5cclxuICAgICAgICAvLyBDcmVhdGUgYW5hbHlzaXMgcmVzdWx0IHdpdGggd2VpZ2h0ZWQgY29uZmlkZW5jZVxyXG4gICAgICAgIGNvbnN0IGFuYWx5c2lzOiBBbmFseXNpcyA9IHtcclxuICAgICAgICAgIGlkOiBgYW5hbHlzaXMtJHtEYXRlLm5vdygpfS0ke2NsZWFuVXNlcm5hbWV9YCxcclxuICAgICAgICAgIHRhcmdldFVzZXJuYW1lOiBjbGVhblVzZXJuYW1lLFxyXG4gICAgICAgICAgYW5hbHl6ZXJVc2VySWQsXHJcbiAgICAgICAgICBjb250cmFkaWN0aW9uc0ZvdW5kOiByZXBvcnREYXRhLmNvbnRyYWRpY3Rpb25zLmxlbmd0aCxcclxuICAgICAgICAgIGNvbmZpZGVuY2VTY29yZTogdGhpcy5jYWxjdWxhdGVXZWlnaHRlZENvbmZpZGVuY2UocmVwb3J0RGF0YS5jb250cmFkaWN0aW9ucyksXHJcbiAgICAgICAgICBhbmFseXNpc0RhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgIHJlcG9ydERhdGEsXHJcbiAgICAgICAgICBzdGF0dXM6ICdjb21wbGV0ZWQnXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5kZWJ1ZyhgQW5hbHlzaXMgY29tcGxldGUgZm9yICR7Y2xlYW5Vc2VybmFtZX06YCwge1xyXG4gICAgICAgICAgY29udHJhZGljdGlvbnNGb3VuZDogYW5hbHlzaXMuY29udHJhZGljdGlvbnNGb3VuZCxcclxuICAgICAgICAgIHdlaWdodGVkQ29uZmlkZW5jZTogYW5hbHlzaXMuY29uZmlkZW5jZVNjb3JlLFxyXG4gICAgICAgICAgdG90YWxJdGVtc0FuYWx5emVkOiB1c2VyRGF0YS5jb21tZW50cy5sZW5ndGggKyB1c2VyRGF0YS5wb3N0cy5sZW5ndGgsXHJcbiAgICAgICAgICBidWRnZXRVc2VkOiB0b2tlbkJ1ZGdldC5nZXRCdWRnZXRTdGF0dXMoKS5zcGVudC50b0ZpeGVkKDQpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGFuYWx5c2lzO1xyXG4gICAgICB9IGNhdGNoIChhaUVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5kZWJ1ZygnQUkgYW5hbHlzaXMgZmFpbGVkOicsIGFpRXJyb3IpO1xyXG4gICAgICAgIHRocm93IGFpRXJyb3I7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLmRlYnVnKCdBbmFseXNpcyBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICBcclxuICAgICAgLy8gUmV0dXJuIGZhaWxlZCBhbmFseXNpcyB3aXRoIGVycm9yIGluZm9cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogYGFuYWx5c2lzLWZhaWxlZC0ke0RhdGUubm93KCl9YCxcclxuICAgICAgICB0YXJnZXRVc2VybmFtZTogdXNlcm5hbWUsXHJcbiAgICAgICAgYW5hbHl6ZXJVc2VySWQsXHJcbiAgICAgICAgY29udHJhZGljdGlvbnNGb3VuZDogMCxcclxuICAgICAgICBjb25maWRlbmNlU2NvcmU6IDAsXHJcbiAgICAgICAgYW5hbHlzaXNEYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgcmVwb3J0RGF0YToge1xyXG4gICAgICAgICAgc3VtbWFyeTogYEFuYWx5c2lzIGZhaWxlZDogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yIG9jY3VycmVkJ31gLFxyXG4gICAgICAgICAgY29udHJhZGljdGlvbnM6IFtdLFxyXG4gICAgICAgICAgdGltZWxpbmU6IFtdLFxyXG4gICAgICAgICAgc3RhdHM6IHtcclxuICAgICAgICAgICAgdG90YWxDb21tZW50czogMCxcclxuICAgICAgICAgICAgdGltZXNwYW46ICcwIGRheXMnLFxyXG4gICAgICAgICAgICB0b3BTdWJyZWRkaXRzOiBbXSxcclxuICAgICAgICAgICAgc2VudGltZW50VHJlbmQ6IDBcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHN0YXR1czogJ2ZhaWxlZCdcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgY2FsY3VsYXRlV2VpZ2h0ZWRDb25maWRlbmNlKGNvbnRyYWRpY3Rpb25zOiBhbnlbXSk6IG51bWJlciB7XHJcbiAgICBpZiAoY29udHJhZGljdGlvbnMubGVuZ3RoID09PSAwKSByZXR1cm4gMDtcclxuXHJcbiAgICAvLyBXZWlnaHQgYnkgcmVjZW5jeSBhbmQgdmVyaWZpY2F0aW9uIHN0YXR1c1xyXG4gICAgbGV0IHRvdGFsV2VpZ2h0ID0gMDtcclxuICAgIGxldCB3ZWlnaHRlZFN1bSA9IDA7XHJcblxyXG4gICAgZm9yIChjb25zdCBjb250cmFkaWN0aW9uIG9mIGNvbnRyYWRpY3Rpb25zKSB7XHJcbiAgICAgIGxldCB3ZWlnaHQgPSAxO1xyXG4gICAgICBcclxuICAgICAgLy8gSGlnaGVyIHdlaWdodCBmb3IgdmVyaWZpZWQgY29udHJhZGljdGlvbnNcclxuICAgICAgaWYgKGNvbnRyYWRpY3Rpb24udmVyaWZpZWQpIHtcclxuICAgICAgICB3ZWlnaHQgKj0gMS41O1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBIaWdoZXIgd2VpZ2h0IGZvciByZWNlbnQgY29udHJhZGljdGlvbnNcclxuICAgICAgY29uc3QgZGF0ZXMgPSBjb250cmFkaWN0aW9uLmRhdGVzLm1hcCgoZDogc3RyaW5nKSA9PiBuZXcgRGF0ZShkKS5nZXRUaW1lKCkpO1xyXG4gICAgICBjb25zdCBhdmdEYXRlID0gKGRhdGVzWzBdICsgZGF0ZXNbMV0pIC8gMjtcclxuICAgICAgY29uc3QgYWdlSW5EYXlzID0gKERhdGUubm93KCkgLSBhdmdEYXRlKSAvICgyNCAqIDYwICogNjAgKiAxMDAwKTtcclxuICAgICAgXHJcbiAgICAgIGlmIChhZ2VJbkRheXMgPCAzMCkge1xyXG4gICAgICAgIHdlaWdodCAqPSAxLjM7IC8vIFJlY2VudCBjb250cmFkaWN0aW9ucyBhcmUgbW9yZSBzaWduaWZpY2FudFxyXG4gICAgICB9IGVsc2UgaWYgKGFnZUluRGF5cyA+IDM2NSkge1xyXG4gICAgICAgIHdlaWdodCAqPSAwLjg7IC8vIE9sZGVyIGNvbnRyYWRpY3Rpb25zIGxlc3Mgc2lnbmlmaWNhbnRcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gV2VpZ2h0IGJ5IGNvbmZpZGVuY2Ugc2NvcmVcclxuICAgICAgd2VpZ2h0ICo9IChjb250cmFkaWN0aW9uLmNvbmZpZGVuY2VTY29yZSAvIDEwMCk7XHJcbiAgICAgIFxyXG4gICAgICB3ZWlnaHRlZFN1bSArPSBjb250cmFkaWN0aW9uLmNvbmZpZGVuY2VTY29yZSAqIHdlaWdodDtcclxuICAgICAgdG90YWxXZWlnaHQgKz0gd2VpZ2h0O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBNYXRoLnJvdW5kKHdlaWdodGVkU3VtIC8gdG90YWxXZWlnaHQpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgdmFsaWRhdGVVc2VybmFtZSh1c2VybmFtZTogc3RyaW5nKTogUHJvbWlzZTxib29sZWFuPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBjbGVhblVzZXJuYW1lID0gdXNlcm5hbWUudHJpbSgpLnJlcGxhY2UoL151XFwvLywgJycpO1xyXG4gICAgICBhd2FpdCByZWRkaXRBcGkuZ2V0VXNlckluZm8oY2xlYW5Vc2VybmFtZSk7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFVzZXJQcmV2aWV3KHVzZXJuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHtcclxuICAgIGV4aXN0czogYm9vbGVhbjtcclxuICAgIGthcm1hOiBudW1iZXI7XHJcbiAgICBhY2NvdW50QWdlOiBzdHJpbmc7XHJcbiAgICByZWNlbnRBY3Rpdml0eTogYm9vbGVhbjtcclxuICAgIGVzdGltYXRlZENvbW1lbnRzOiBudW1iZXI7XHJcbiAgfT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY2xlYW5Vc2VybmFtZSA9IHVzZXJuYW1lLnRyaW0oKS5yZXBsYWNlKC9edVxcLy8sICcnKTtcclxuICAgICAgcmV0dXJuIGF3YWl0IHJlZGRpdEFwaS5nZXRVc2VyUHJldmlldyhjbGVhblVzZXJuYW1lKTtcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGV4aXN0czogZmFsc2UsXHJcbiAgICAgICAga2FybWE6IDAsXHJcbiAgICAgICAgYWNjb3VudEFnZTogJ1Vua25vd24nLFxyXG4gICAgICAgIHJlY2VudEFjdGl2aXR5OiBmYWxzZSxcclxuICAgICAgICBlc3RpbWF0ZWRDb21tZW50czogMFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gRW5oYW5jZWQgY2FjaGUgbWFuYWdlbWVudFxyXG4gIGNsZWFyVXNlckNhY2hlKHVzZXJuYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGNvbnN0IGNsZWFuVXNlcm5hbWUgPSB1c2VybmFtZS50cmltKCkucmVwbGFjZSgvXnVcXC8vLCAnJyk7XHJcbiAgICBjYWNoZVNlcnZpY2UuY2xlYXJBbmFseXNpcyhjbGVhblVzZXJuYW1lKTtcclxuICB9XHJcblxyXG4gIGdldENhY2hlU3RhdHMoKSB7XHJcbiAgICByZXR1cm4gY2FjaGVTZXJ2aWNlLmdldFN0YXRzKCk7XHJcbiAgfVxyXG5cclxuICBnZXRCdWRnZXRTdGF0cygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGJ1ZGdldDogdG9rZW5CdWRnZXQuZ2V0QnVkZ2V0U3RhdHVzKCksXHJcbiAgICAgIHVzYWdlOiB0b2tlbkJ1ZGdldC5nZXRVc2FnZVN0YXRzKClcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICByZXNldEJ1ZGdldCgpOiB2b2lkIHtcclxuICAgIHRva2VuQnVkZ2V0LnJlc2V0QnVkZ2V0KCk7XHJcbiAgfVxyXG5cclxuICBzZXRCdWRnZXQobWF4RG9sbGFyOiBudW1iZXIsIHdhcm5pbmdUaHJlc2hvbGQ6IG51bWJlciA9IDgwKTogdm9pZCB7XHJcbiAgICB0b2tlbkJ1ZGdldC5zZXRCdWRnZXQoeyBtYXhEb2xsYXIsIHdhcm5pbmdUaHJlc2hvbGQgfSk7XHJcbiAgfVxyXG5cclxuICAvLyBEZWJ1ZyBhbmQgbW9uaXRvcmluZyBtZXRob2RzXHJcbiAgZ2V0RGVidWdJbmZvKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2FjaGU6IGNhY2hlU2VydmljZS5nZXREZWJ1Z0luZm8oKSxcclxuICAgICAgYnVkZ2V0OiB0aGlzLmdldEJ1ZGdldFN0YXRzKCksXHJcbiAgICAgIHZlcmJvc2U6IHRoaXMudmVyYm9zZVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIFN0cmVhbWluZyBhbmFseXNpcyBmb3IgbGFyZ2UgZGF0YXNldHNcclxuICBhc3luYyogYW5hbHl6ZVVzZXJTdHJlYW0odXNlcm5hbWU6IHN0cmluZyk6IEFzeW5jR2VuZXJhdG9yPHtcclxuICAgIHN0YWdlOiBzdHJpbmc7XHJcbiAgICBwcm9ncmVzczogbnVtYmVyO1xyXG4gICAgZGF0YT86IGFueTtcclxuICB9LCB2b2lkLCB1bmtub3duPiB7XHJcbiAgICBjb25zdCBjbGVhblVzZXJuYW1lID0gdXNlcm5hbWUudHJpbSgpLnJlcGxhY2UoL151XFwvLywgJycpO1xyXG4gICAgXHJcbiAgICB5aWVsZCB7IHN0YWdlOiAndmFsaWRhdGlvbicsIHByb2dyZXNzOiAwIH07XHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFZhbGlkYXRlIHVzZXJcclxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHJlZGRpdEFwaS5nZXRVc2VySW5mbyhjbGVhblVzZXJuYW1lKTtcclxuICAgICAgeWllbGQgeyBzdGFnZTogJ3ZhbGlkYXRpb24nLCBwcm9ncmVzczogMTAwLCBkYXRhOiB7IHVzZXIgfSB9O1xyXG4gICAgICBcclxuICAgICAgLy8gU3RyZWFtIGNvbW1lbnRzXHJcbiAgICAgIHlpZWxkIHsgc3RhZ2U6ICdmZXRjaGluZycsIHByb2dyZXNzOiAwIH07XHJcbiAgICAgIGNvbnN0IGNvbW1lbnRzOiBhbnlbXSA9IFtdO1xyXG4gICAgICBjb25zdCBwb3N0czogYW55W10gPSBbXTtcclxuICAgICAgXHJcbiAgICAgIGxldCBmZXRjaFByb2dyZXNzID0gMDtcclxuICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiByZWRkaXRBcGkuaXRlcmF0ZUNvbW1lbnRzKGNsZWFuVXNlcm5hbWUsIHsgbWF4SXRlbXM6IDUwMDAgfSkpIHtcclxuICAgICAgICBjb21tZW50cy5wdXNoKC4uLmJhdGNoKTtcclxuICAgICAgICBmZXRjaFByb2dyZXNzICs9IDEwO1xyXG4gICAgICAgIHlpZWxkIHsgc3RhZ2U6ICdmZXRjaGluZycsIHByb2dyZXNzOiBNYXRoLm1pbihmZXRjaFByb2dyZXNzLCA4MCkgfTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gU3RyZWFtIHBvc3RzXHJcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgYmF0Y2ggb2YgcmVkZGl0QXBpLml0ZXJhdGVQb3N0cyhjbGVhblVzZXJuYW1lLCB7IG1heEl0ZW1zOiAxMDAwIH0pKSB7XHJcbiAgICAgICAgcG9zdHMucHVzaCguLi5iYXRjaCk7XHJcbiAgICAgICAgZmV0Y2hQcm9ncmVzcyArPSA1O1xyXG4gICAgICAgIHlpZWxkIHsgc3RhZ2U6ICdmZXRjaGluZycsIHByb2dyZXNzOiBNYXRoLm1pbihmZXRjaFByb2dyZXNzLCAxMDApIH07XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHlpZWxkIHsgc3RhZ2U6ICdmZXRjaGluZycsIHByb2dyZXNzOiAxMDAsIGRhdGE6IHsgY29tbWVudHM6IGNvbW1lbnRzLmxlbmd0aCwgcG9zdHM6IHBvc3RzLmxlbmd0aCB9IH07XHJcbiAgICAgIFxyXG4gICAgICAvLyBBbmFseXNpc1xyXG4gICAgICB5aWVsZCB7IHN0YWdlOiAnYW5hbHl6aW5nJywgcHJvZ3Jlc3M6IDAgfTtcclxuICAgICAgY29uc3QgcmVwb3J0RGF0YSA9IGF3YWl0IG11bHRpTW9kZWxQaXBlbGluZS5hbmFseXplVXNlcihjb21tZW50cywgcG9zdHMsIGNsZWFuVXNlcm5hbWUpO1xyXG4gICAgICB5aWVsZCB7IHN0YWdlOiAnYW5hbHl6aW5nJywgcHJvZ3Jlc3M6IDEwMCwgZGF0YTogcmVwb3J0RGF0YSB9O1xyXG4gICAgICBcclxuICAgICAgLy8gQ29tcGxldGVcclxuICAgICAgeWllbGQgeyBzdGFnZTogJ2NvbXBsZXRlJywgcHJvZ3Jlc3M6IDEwMCwgZGF0YTogcmVwb3J0RGF0YSB9O1xyXG4gICAgICBcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHlpZWxkIHsgc3RhZ2U6ICdlcnJvcicsIHByb2dyZXNzOiAwLCBkYXRhOiB7IGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyB9IH07XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgY29uc3QgYW5hbHlzaXNTZXJ2aWNlID0gbmV3IEFuYWx5c2lzU2VydmljZSgpOyJdLCJuYW1lcyI6WyJyZWRkaXRBcGkiLCJtdWx0aU1vZGVsUGlwZWxpbmUiLCJjYWNoZVNlcnZpY2UiLCJ0b2tlbkJ1ZGdldCIsIkFuYWx5c2lzU2VydmljZSIsInNldFZlcmJvc2UiLCJ2ZXJib3NlIiwiZGVidWciLCJhcmdzIiwiY29uc29sZSIsImxvZyIsImFuYWx5emVVc2VyIiwidXNlcm5hbWUiLCJhbmFseXplclVzZXJJZCIsInRyaW0iLCJsZW5ndGgiLCJFcnJvciIsImNsZWFuVXNlcm5hbWUiLCJyZXBsYWNlIiwiYnVkZ2V0U3RhdHVzIiwiZ2V0QnVkZ2V0U3RhdHVzIiwiaXNXYXJuaW5nIiwid2FybiIsInBlcmNlbnRhZ2UiLCJ0b0ZpeGVkIiwidXNlckRhdGEiLCJnZXRGdWxsVXNlckRhdGEiLCJtYXhJdGVtcyIsIm1heEFnZSIsInVzZXIiLCJjb21tZW50cyIsInBvc3RzIiwidG90YWxDb250ZW50IiwidXNlckthcm1hIiwidG90YWxfa2FybWEiLCJhY2NvdW50QWdlIiwiTWF0aCIsImZsb29yIiwiRGF0ZSIsIm5vdyIsImNyZWF0ZWRfdXRjIiwiaGFzVmFsaWRBbmFseXNpcyIsImNhY2hlZFJlcG9ydCIsImdldEFuYWx5c2lzIiwiaWQiLCJ0YXJnZXRVc2VybmFtZSIsImNvbnRyYWRpY3Rpb25zRm91bmQiLCJjb250cmFkaWN0aW9ucyIsImNvbmZpZGVuY2VTY29yZSIsImNhbGN1bGF0ZVdlaWdodGVkQ29uZmlkZW5jZSIsImFuYWx5c2lzRGF0ZSIsInRvSVNPU3RyaW5nIiwicmVwb3J0RGF0YSIsInN0YXR1cyIsImFuYWx5c2lzIiwid2VpZ2h0ZWRDb25maWRlbmNlIiwidG90YWxJdGVtc0FuYWx5emVkIiwiYnVkZ2V0VXNlZCIsInNwZW50IiwiYWlFcnJvciIsImVycm9yIiwic3VtbWFyeSIsIm1lc3NhZ2UiLCJ0aW1lbGluZSIsInN0YXRzIiwidG90YWxDb21tZW50cyIsInRpbWVzcGFuIiwidG9wU3VicmVkZGl0cyIsInNlbnRpbWVudFRyZW5kIiwidG90YWxXZWlnaHQiLCJ3ZWlnaHRlZFN1bSIsImNvbnRyYWRpY3Rpb24iLCJ3ZWlnaHQiLCJ2ZXJpZmllZCIsImRhdGVzIiwibWFwIiwiZCIsImdldFRpbWUiLCJhdmdEYXRlIiwiYWdlSW5EYXlzIiwicm91bmQiLCJ2YWxpZGF0ZVVzZXJuYW1lIiwiZ2V0VXNlckluZm8iLCJnZXRVc2VyUHJldmlldyIsImV4aXN0cyIsImthcm1hIiwicmVjZW50QWN0aXZpdHkiLCJlc3RpbWF0ZWRDb21tZW50cyIsImNsZWFyVXNlckNhY2hlIiwiY2xlYXJBbmFseXNpcyIsImdldENhY2hlU3RhdHMiLCJnZXRTdGF0cyIsImdldEJ1ZGdldFN0YXRzIiwiYnVkZ2V0IiwidXNhZ2UiLCJnZXRVc2FnZVN0YXRzIiwicmVzZXRCdWRnZXQiLCJzZXRCdWRnZXQiLCJtYXhEb2xsYXIiLCJ3YXJuaW5nVGhyZXNob2xkIiwiZ2V0RGVidWdJbmZvIiwiY2FjaGUiLCJhbmFseXplVXNlclN0cmVhbSIsInN0YWdlIiwicHJvZ3Jlc3MiLCJkYXRhIiwiZmV0Y2hQcm9ncmVzcyIsImJhdGNoIiwiaXRlcmF0ZUNvbW1lbnRzIiwicHVzaCIsIm1pbiIsIml0ZXJhdGVQb3N0cyIsImFuYWx5c2lzU2VydmljZSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/services/analysisService.ts\n"));

/***/ })

});