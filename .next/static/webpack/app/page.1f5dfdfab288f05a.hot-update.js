"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/services/cacheService.ts":
/*!******************************************!*\
  !*** ./src/lib/services/cacheService.ts ***!
  \******************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cacheService: () => (/* binding */ cacheService)\n/* harmony export */ });\nclass CacheService {\n    loadFromStorage() {\n        try {\n            const stored = localStorage.getItem('thoughtPoliceCache');\n            if (stored) {\n                const data = JSON.parse(stored);\n                // Validate cache version\n                if (data.version !== this.CACHE_VERSION) {\n                    console.log('Cache version mismatch, clearing cache');\n                    this.clearAll();\n                    return;\n                }\n                // Load entries\n                if (data.entries) {\n                    for (const [key, entry] of Object.entries(data.entries)){\n                        this.cache.set(key, entry);\n                    }\n                }\n                console.log(\"Loaded \".concat(this.cache.size, \" cache entries from storage\"));\n                this.cleanupExpired();\n            }\n        } catch (error) {\n            console.warn('Failed to load cache from storage:', error);\n            this.clearAll();\n        }\n    }\n    saveToStorage() {\n        const data = {\n            version: this.CACHE_VERSION,\n            entries: Object.fromEntries(this.cache.entries()),\n            lastSaved: Date.now()\n        };\n        try {\n            localStorage.setItem('thoughtPoliceCache', JSON.stringify(data));\n        } catch (error) {\n            console.warn('Failed to save cache to storage:', error);\n            // If storage is full, try to free up space\n            if (error instanceof Error && error.name === 'QuotaExceededError') {\n                this.evictOldest(Math.floor(this.cache.size / 2));\n                try {\n                    localStorage.setItem('thoughtPoliceCache', JSON.stringify(data));\n                } catch (e) {\n                    console.warn('Cache storage still full after eviction');\n                }\n            }\n        }\n    }\n    setupPeriodicCleanup() {\n        // Clean up expired entries every 10 minutes\n        setInterval(()=>{\n            this.cleanupExpired();\n        }, 10 * 60 * 1000);\n    }\n    generateContentHash(comments, posts) {\n        // Create a hash based on the latest content timestamps\n        const latestComment = comments.length > 0 ? Math.max(...comments.map((c)=>c.created_utc)) : 0;\n        const latestPost = posts.length > 0 ? Math.max(...posts.map((p)=>p.created_utc)) : 0;\n        const latest = Math.max(latestComment, latestPost);\n        // Include content count for additional validation\n        const contentSignature = \"\".concat(latest, \"-\").concat(comments.length, \"-\").concat(posts.length);\n        // Simple hash function\n        let hash = 0;\n        for(let i = 0; i < contentSignature.length; i++){\n            const char = contentSignature.charCodeAt(i);\n            hash = (hash << 5) - hash + char;\n            hash = hash & hash; // Convert to 32-bit integer\n        }\n        return Math.abs(hash).toString(36);\n    }\n    getAnalysisKey(username, contentHash) {\n        return \"analysis:\".concat(username.toLowerCase(), \":\").concat(contentHash);\n    }\n    evictOldest(count) {\n        const entries = Array.from(this.cache.entries()).sort((param, param1)=>{\n            let [, a] = param, [, b] = param1;\n            return a.timestamp - b.timestamp;\n        });\n        for(let i = 0; i < Math.min(count, entries.length); i++){\n            this.cache.delete(entries[i][0]);\n        }\n        console.log(\"Evicted \".concat(Math.min(count, entries.length), \" oldest cache entries\"));\n    }\n    cleanupExpired() {\n        const now = Date.now();\n        let cleanedCount = 0;\n        this.cache.forEach((entry, key)=>{\n            if (now > entry.expiresAt) {\n                this.cache.delete(key);\n                cleanedCount++;\n            }\n        });\n        if (cleanedCount > 0) {\n            console.log(\"Cleaned up \".concat(cleanedCount, \" expired cache entries\"));\n            this.saveToStorage();\n        }\n    }\n    /**\r\n   * Store analysis result in cache with content-based invalidation\r\n   */ setAnalysis(username, data) {\n        let comments = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], posts = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [], ttl = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.DEFAULT_TTL;\n        const contentHash = this.generateContentHash(comments, posts);\n        const key = this.getAnalysisKey(username, contentHash);\n        const entry = {\n            data,\n            timestamp: Date.now(),\n            expiresAt: Date.now() + ttl,\n            contentHash,\n            version: this.CACHE_VERSION\n        };\n        // Enforce cache size limit\n        if (this.cache.size >= this.MAX_CACHE_SIZE) {\n            this.evictOldest(1);\n        }\n        this.cache.set(key, entry);\n        console.log(\"Cached analysis for user: \".concat(username, \", hash: \").concat(contentHash, \", expires in \").concat(Math.round(ttl / (24 * 60 * 60 * 1000)), \" days\"));\n        this.saveToStorage();\n    }\n    /**\r\n   * Get cached analysis result with content validation\r\n   */ getAnalysis(username) {\n        let comments = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], posts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n        const contentHash = this.generateContentHash(comments, posts);\n        const key = this.getAnalysisKey(username, contentHash);\n        const entry = this.cache.get(key);\n        if (!entry) {\n            this.misses++;\n            // Check if we have any cache for this user (with different content)\n            const userKeys = Array.from(this.cache.keys()).filter((k)=>k.startsWith(\"analysis:\".concat(username.toLowerCase(), \":\")));\n            if (userKeys.length > 0) {\n                console.log(\"Cache miss for user: \".concat(username, \" - content has changed (hash: \").concat(contentHash, \")\"));\n                // Clean up old entries for this user\n                userKeys.forEach((oldKey)=>this.cache.delete(oldKey));\n                this.saveToStorage();\n            }\n            return null;\n        }\n        if (Date.now() > entry.expiresAt) {\n            this.cache.delete(key);\n            this.misses++;\n            console.log(\"Cache expired for user: \".concat(username));\n            this.saveToStorage();\n            return null;\n        }\n        this.hits++;\n        const age = Math.round((Date.now() - entry.timestamp) / (60 * 60 * 1000));\n        console.log(\"Cache hit for user: \".concat(username, \", age: \").concat(age, \" hours, hash: \").concat(contentHash));\n        return entry.data;\n    }\n    /**\r\n   * Check if analysis is cached and still valid\r\n   */ hasValidAnalysis(username) {\n        let comments = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], posts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n        return this.getAnalysis(username, comments, posts) !== null;\n    }\n    /**\r\n   * Clear cache for specific user (all content versions)\r\n   */ clearAnalysis(username) {\n        const userKeys = Array.from(this.cache.keys()).filter((k)=>k.startsWith(\"analysis:\".concat(username.toLowerCase(), \":\")));\n        userKeys.forEach((key)=>this.cache.delete(key));\n        console.log(\"Cleared \".concat(userKeys.length, \" cache entries for user: \").concat(username));\n        this.saveToStorage();\n    }\n    /**\r\n   * Clear all cached data\r\n   */ clearAll() {\n        this.cache.clear();\n        this.hits = 0;\n        this.misses = 0;\n        console.log('Cleared all cached analyses');\n        this.saveToStorage();\n    }\n    /**\r\n   * Get comprehensive cache statistics\r\n   */ getStats() {\n        const now = Date.now();\n        let validEntries = 0;\n        let expiredEntries = 0;\n        let totalSize = 0;\n        this.cache.forEach((entry)=>{\n            if (now <= entry.expiresAt) {\n                validEntries++;\n            } else {\n                expiredEntries++;\n            }\n            // Estimate size (rough approximation)\n            totalSize += JSON.stringify(entry).length;\n        });\n        const totalRequests = this.hits + this.misses;\n        const hitRate = totalRequests > 0 ? this.hits / totalRequests * 100 : 0;\n        return {\n            totalEntries: this.cache.size,\n            validEntries,\n            expiredEntries,\n            totalSize,\n            hitRate\n        };\n    }\n    /**\r\n   * Get cache entries for debugging\r\n   */ getDebugInfo() {\n        const now = Date.now();\n        return Array.from(this.cache.entries()).map((param)=>{\n            let [key, entry] = param;\n            const parts = key.split(':');\n            const username = parts[1] || 'unknown';\n            const contentHash = parts[2] || 'unknown';\n            const ageMs = now - entry.timestamp;\n            const age = ageMs < 60000 ? \"\".concat(Math.round(ageMs / 1000), \"s\") : ageMs < 3600000 ? \"\".concat(Math.round(ageMs / 60000), \"m\") : \"\".concat(Math.round(ageMs / 3600000), \"h\");\n            return {\n                key,\n                username,\n                contentHash,\n                age,\n                size: JSON.stringify(entry).length,\n                isExpired: now > entry.expiresAt\n            };\n        }).sort((a, b)=>a.username.localeCompare(b.username));\n    }\n    constructor(){\n        this.cache = new Map();\n        this.DEFAULT_TTL = 7 * 24 * 60 * 60 * 1000 // 7 days\n        ;\n        this.CACHE_VERSION = '2.0';\n        this.MAX_CACHE_SIZE = 50 // Maximum number of cached analyses\n        ;\n        this.hits = 0;\n        this.misses = 0;\n        this.loadFromStorage();\n        this.setupPeriodicCleanup();\n    }\n}\nconst cacheService = new CacheService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2VydmljZXMvY2FjaGVTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFnQkEsTUFBTUE7SUFhSUMsa0JBQXdCO1FBQzlCLElBQUk7WUFDRixNQUFNQyxTQUFTQyxhQUFhQyxPQUFPLENBQUM7WUFDcEMsSUFBSUYsUUFBUTtnQkFDVixNQUFNRyxPQUFPQyxLQUFLQyxLQUFLLENBQUNMO2dCQUV4Qix5QkFBeUI7Z0JBQ3pCLElBQUlHLEtBQUtHLE9BQU8sS0FBSyxJQUFJLENBQUNDLGFBQWEsRUFBRTtvQkFDdkNDLFFBQVFDLEdBQUcsQ0FBQztvQkFDWixJQUFJLENBQUNDLFFBQVE7b0JBQ2I7Z0JBQ0Y7Z0JBRUEsZUFBZTtnQkFDZixJQUFJUCxLQUFLUSxPQUFPLEVBQUU7b0JBQ2hCLEtBQUssTUFBTSxDQUFDQyxLQUFLQyxNQUFNLElBQUlDLE9BQU9ILE9BQU8sQ0FBQ1IsS0FBS1EsT0FBTyxFQUFHO3dCQUN2RCxJQUFJLENBQUNJLEtBQUssQ0FBQ0MsR0FBRyxDQUFDSixLQUFLQztvQkFDdEI7Z0JBQ0Y7Z0JBRUFMLFFBQVFDLEdBQUcsQ0FBQyxVQUEwQixPQUFoQixJQUFJLENBQUNNLEtBQUssQ0FBQ0UsSUFBSSxFQUFDO2dCQUN0QyxJQUFJLENBQUNDLGNBQWM7WUFDckI7UUFDRixFQUFFLE9BQU9DLE9BQU87WUFDZFgsUUFBUVksSUFBSSxDQUFDLHNDQUFzQ0Q7WUFDbkQsSUFBSSxDQUFDVCxRQUFRO1FBQ2Y7SUFDRjtJQUVRVyxnQkFBc0I7UUFDNUIsTUFBTWxCLE9BQU87WUFDWEcsU0FBUyxJQUFJLENBQUNDLGFBQWE7WUFDM0JJLFNBQVNHLE9BQU9RLFdBQVcsQ0FBQyxJQUFJLENBQUNQLEtBQUssQ0FBQ0osT0FBTztZQUM5Q1ksV0FBV0MsS0FBS0MsR0FBRztRQUNyQjtRQUNBLElBQUk7WUFDRnhCLGFBQWF5QixPQUFPLENBQUMsc0JBQXNCdEIsS0FBS3VCLFNBQVMsQ0FBQ3hCO1FBQzVELEVB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USxDQUFDOEMsYUFBYSxDQUFDdEMsRUFBRVIsUUFBUTtJQUN2RDtJQWxSQStDLGFBQWM7YUFQTnZGLFFBQVEsSUFBSXdGO2FBQ0gvQixjQUFjLElBQUksS0FBSyxLQUFLLEtBQUssS0FBTSxTQUFTOzthQUNoRGpFLGdCQUFnQjthQUNoQmtFLGlCQUFpQixHQUFJLG9DQUFvQzs7YUFDbEVXLE9BQU87YUFDUFAsU0FBUztRQUdmLElBQUksQ0FBQzlFLGVBQWU7UUFDcEIsSUFBSSxDQUFDa0Msb0JBQW9CO0lBQzNCO0FBZ1JGO0FBRU8sTUFBTXVFLGVBQWUsSUFBSTFHLGVBQWUiLCJzb3VyY2VzIjpbIkQ6XFxjb2RpbmdcXGxhdW5jaFxcdGhvdWdodFBvbGljZVxcc3JjXFxsaWJcXHNlcnZpY2VzXFxjYWNoZVNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW50ZXJmYWNlIENhY2hlRW50cnkge1xyXG4gIGRhdGE6IGFueTtcclxuICB0aW1lc3RhbXA6IG51bWJlcjtcclxuICBleHBpcmVzQXQ6IG51bWJlcjtcclxuICBjb250ZW50SGFzaDogc3RyaW5nO1xyXG4gIHZlcnNpb246IHN0cmluZztcclxufVxyXG5cclxuaW50ZXJmYWNlIENhY2hlU3RhdHMge1xyXG4gIHRvdGFsRW50cmllczogbnVtYmVyO1xyXG4gIHZhbGlkRW50cmllczogbnVtYmVyO1xyXG4gIGV4cGlyZWRFbnRyaWVzOiBudW1iZXI7XHJcbiAgdG90YWxTaXplOiBudW1iZXI7XHJcbiAgaGl0UmF0ZTogbnVtYmVyO1xyXG59XHJcblxyXG5jbGFzcyBDYWNoZVNlcnZpY2Uge1xyXG4gIHByaXZhdGUgY2FjaGUgPSBuZXcgTWFwPHN0cmluZywgQ2FjaGVFbnRyeT4oKTtcclxuICBwcml2YXRlIHJlYWRvbmx5IERFRkFVTFRfVFRMID0gNyAqIDI0ICogNjAgKiA2MCAqIDEwMDA7IC8vIDcgZGF5c1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgQ0FDSEVfVkVSU0lPTiA9ICcyLjAnO1xyXG4gIHByaXZhdGUgcmVhZG9ubHkgTUFYX0NBQ0hFX1NJWkUgPSA1MDsgLy8gTWF4aW11bSBudW1iZXIgb2YgY2FjaGVkIGFuYWx5c2VzXHJcbiAgcHJpdmF0ZSBoaXRzID0gMDtcclxuICBwcml2YXRlIG1pc3NlcyA9IDA7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5sb2FkRnJvbVN0b3JhZ2UoKTtcclxuICAgIHRoaXMuc2V0dXBQZXJpb2RpY0NsZWFudXAoKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgbG9hZEZyb21TdG9yYWdlKCk6IHZvaWQge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RvcmVkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3Rob3VnaHRQb2xpY2VDYWNoZScpO1xyXG4gICAgICBpZiAoc3RvcmVkKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBWYWxpZGF0ZSBjYWNoZSB2ZXJzaW9uXHJcbiAgICAgICAgaWYgKGRhdGEudmVyc2lvbiAhPT0gdGhpcy5DQUNIRV9WRVJTSU9OKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ2FjaGUgdmVyc2lvbiBtaXNtYXRjaCwgY2xlYXJpbmcgY2FjaGUnKTtcclxuICAgICAgICAgIHRoaXMuY2xlYXJBbGwoKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExvYWQgZW50cmllc1xyXG4gICAgICAgIGlmIChkYXRhLmVudHJpZXMpIHtcclxuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEuZW50cmllcykpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZS5zZXQoa2V5LCBlbnRyeSBhcyBDYWNoZUVudHJ5KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBMb2FkZWQgJHt0aGlzLmNhY2hlLnNpemV9IGNhY2hlIGVudHJpZXMgZnJvbSBzdG9yYWdlYCk7XHJcbiAgICAgICAgdGhpcy5jbGVhbnVwRXhwaXJlZCgpO1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBsb2FkIGNhY2hlIGZyb20gc3RvcmFnZTonLCBlcnJvcik7XHJcbiAgICAgIHRoaXMuY2xlYXJBbGwoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgc2F2ZVRvU3RvcmFnZSgpOiB2b2lkIHtcclxuICAgIGNvbnN0IGRhdGEgPSB7XHJcbiAgICAgIHZlcnNpb246IHRoaXMuQ0FDSEVfVkVSU0lPTixcclxuICAgICAgZW50cmllczogT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuY2FjaGUuZW50cmllcygpKSxcclxuICAgICAgbGFzdFNhdmVkOiBEYXRlLm5vdygpXHJcbiAgICB9O1xyXG4gICAgdHJ5IHtcclxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Rob3VnaHRQb2xpY2VDYWNoZScsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIHNhdmUgY2FjaGUgdG8gc3RvcmFnZTonLCBlcnJvcik7XHJcbiAgICAgIFxyXG4gICAgICAvLyBJZiBzdG9yYWdlIGlzIGZ1bGwsIHRyeSB0byBmcmVlIHVwIHNwYWNlXHJcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09ICdRdW90YUV4Y2VlZGVkRXJyb3InKSB7XHJcbiAgICAgICAgdGhpcy5ldmljdE9sZGVzdChNYXRoLmZsb29yKHRoaXMuY2FjaGUuc2l6ZSAvIDIpKTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3Rob3VnaHRQb2xpY2VDYWNoZScsIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcclxuICAgICAgICB9IGNhdGNoIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybignQ2FjaGUgc3RvcmFnZSBzdGlsbCBmdWxsIGFmdGVyIGV2aWN0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHNldHVwUGVyaW9kaWNDbGVhbnVwKCk6IHZvaWQge1xyXG4gICAgLy8gQ2xlYW4gdXAgZXhwaXJlZCBlbnRyaWVzIGV2ZXJ5IDEwIG1pbnV0ZXNcclxuICAgIHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgdGhpcy5jbGVhbnVwRXhwaXJlZCgpO1xyXG4gICAgfSwgMTAgKiA2MCAqIDEwMDApO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZW5lcmF0ZUNvbnRlbnRIYXNoKGNvbW1lbnRzOiBhbnlbXSwgcG9zdHM6IGFueVtdKTogc3RyaW5nIHtcclxuICAgIC8vIENyZWF0ZSBhIGhhc2ggYmFzZWQgb24gdGhlIGxhdGVzdCBjb250ZW50IHRpbWVzdGFtcHNcclxuICAgIGNvbnN0IGxhdGVzdENvbW1lbnQgPSBjb21tZW50cy5sZW5ndGggPiAwID8gTWF0aC5tYXgoLi4uY29tbWVudHMubWFwKGMgPT4gYy5jcmVhdGVkX3V0YykpIDogMDtcclxuICAgIGNvbnN0IGxhdGVzdFBvc3QgPSBwb3N0cy5sZW5ndGggPiAwID8gTWF0aC5tYXgoLi4ucG9zdHMubWFwKHAgPT4gcC5jcmVhdGVkX3V0YykpIDogMDtcclxuICAgIGNvbnN0IGxhdGVzdCA9IE1hdGgubWF4KGxhdGVzdENvbW1lbnQsIGxhdGVzdFBvc3QpO1xyXG4gICAgXHJcbiAgICAvLyBJbmNsdWRlIGNvbnRlbnQgY291bnQgZm9yIGFkZGl0aW9uYWwgdmFsaWRhdGlvblxyXG4gICAgY29uc3QgY29udGVudFNpZ25hdHVyZSA9IGAke2xhdGVzdH0tJHtjb21tZW50cy5sZW5ndGh9LSR7cG9zdHMubGVuZ3RofWA7XHJcbiAgICBcclxuICAgIC8vIFNpbXBsZSBoYXNoIGZ1bmN0aW9uXHJcbiAgICBsZXQgaGFzaCA9IDA7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnRTaWduYXR1cmUubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgY2hhciA9IGNvbnRlbnRTaWduYXR1cmUuY2hhckNvZGVBdChpKTtcclxuICAgICAgaGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgY2hhcjtcclxuICAgICAgaGFzaCA9IGhhc2ggJiBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyLWJpdCBpbnRlZ2VyXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBNYXRoLmFicyhoYXNoKS50b1N0cmluZygzNik7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldEFuYWx5c2lzS2V5KHVzZXJuYW1lOiBzdHJpbmcsIGNvbnRlbnRIYXNoOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIGBhbmFseXNpczoke3VzZXJuYW1lLnRvTG93ZXJDYXNlKCl9OiR7Y29udGVudEhhc2h9YDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZXZpY3RPbGRlc3QoY291bnQ6IG51bWJlcik6IHZvaWQge1xyXG4gICAgY29uc3QgZW50cmllcyA9IEFycmF5LmZyb20odGhpcy5jYWNoZS5lbnRyaWVzKCkpXHJcbiAgICAgIC5zb3J0KChbLGFdLCBbLGJdKSA9PiBhLnRpbWVzdGFtcCAtIGIudGltZXN0YW1wKTtcclxuICAgIFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBNYXRoLm1pbihjb3VudCwgZW50cmllcy5sZW5ndGgpOyBpKyspIHtcclxuICAgICAgdGhpcy5jYWNoZS5kZWxldGUoZW50cmllc1tpXVswXSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGBFdmljdGVkICR7TWF0aC5taW4oY291bnQsIGVudHJpZXMubGVuZ3RoKX0gb2xkZXN0IGNhY2hlIGVudHJpZXNgKTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY2xlYW51cEV4cGlyZWQoKTogdm9pZCB7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgbGV0IGNsZWFuZWRDb3VudCA9IDA7XHJcbiAgICBcclxuICAgIHRoaXMuY2FjaGUuZm9yRWFjaCgoZW50cnksIGtleSkgPT4ge1xyXG4gICAgICBpZiAobm93ID4gZW50cnkuZXhwaXJlc0F0KSB7XHJcbiAgICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcclxuICAgICAgICBjbGVhbmVkQ291bnQrKztcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGlmIChjbGVhbmVkQ291bnQgPiAwKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBDbGVhbmVkIHVwICR7Y2xlYW5lZENvdW50fSBleHBpcmVkIGNhY2hlIGVudHJpZXNgKTtcclxuICAgICAgdGhpcy5zYXZlVG9TdG9yYWdlKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9yZSBhbmFseXNpcyByZXN1bHQgaW4gY2FjaGUgd2l0aCBjb250ZW50LWJhc2VkIGludmFsaWRhdGlvblxyXG4gICAqL1xyXG4gIHNldEFuYWx5c2lzKHVzZXJuYW1lOiBzdHJpbmcsIGRhdGE6IGFueSwgY29tbWVudHM6IGFueVtdID0gW10sIHBvc3RzOiBhbnlbXSA9IFtdLCB0dGw6IG51bWJlciA9IHRoaXMuREVGQVVMVF9UVEwpOiB2b2lkIHtcclxuICAgIGNvbnN0IGNvbnRlbnRIYXNoID0gdGhpcy5nZW5lcmF0ZUNvbnRlbnRIYXNoKGNvbW1lbnRzLCBwb3N0cyk7XHJcbiAgICBjb25zdCBrZXkgPSB0aGlzLmdldEFuYWx5c2lzS2V5KHVzZXJuYW1lLCBjb250ZW50SGFzaCk7XHJcbiAgICBcclxuICAgIGNvbnN0IGVudHJ5OiBDYWNoZUVudHJ5ID0ge1xyXG4gICAgICBkYXRhLFxyXG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXHJcbiAgICAgIGV4cGlyZXNBdDogRGF0ZS5ub3coKSArIHR0bCxcclxuICAgICAgY29udGVudEhhc2gsXHJcbiAgICAgIHZlcnNpb246IHRoaXMuQ0FDSEVfVkVSU0lPTlxyXG4gICAgfTtcclxuICAgIFxyXG4gICAgLy8gRW5mb3JjZSBjYWNoZSBzaXplIGxpbWl0XHJcbiAgICBpZiAodGhpcy5jYWNoZS5zaXplID49IHRoaXMuTUFYX0NBQ0hFX1NJWkUpIHtcclxuICAgICAgdGhpcy5ldmljdE9sZGVzdCgxKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5jYWNoZS5zZXQoa2V5LCBlbnRyeSk7XHJcbiAgICBjb25zb2xlLmxvZyhgQ2FjaGVkIGFuYWx5c2lzIGZvciB1c2VyOiAke3VzZXJuYW1lfSwgaGFzaDogJHtjb250ZW50SGFzaH0sIGV4cGlyZXMgaW4gJHtNYXRoLnJvdW5kKHR0bCAvICgyNCAqIDYwICogNjAgKiAxMDAwKSl9IGRheXNgKTtcclxuICAgIFxyXG4gICAgdGhpcy5zYXZlVG9TdG9yYWdlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgY2FjaGVkIGFuYWx5c2lzIHJlc3VsdCB3aXRoIGNvbnRlbnQgdmFsaWRhdGlvblxyXG4gICAqL1xyXG4gIGdldEFuYWx5c2lzKHVzZXJuYW1lOiBzdHJpbmcsIGNvbW1lbnRzOiBhbnlbXSA9IFtdLCBwb3N0czogYW55W10gPSBbXSk6IGFueSB8IG51bGwge1xyXG4gICAgY29uc3QgY29udGVudEhhc2ggPSB0aGlzLmdlbmVyYXRlQ29udGVudEhhc2goY29tbWVudHMsIHBvc3RzKTtcclxuICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0QW5hbHlzaXNLZXkodXNlcm5hbWUsIGNvbnRlbnRIYXNoKTtcclxuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5jYWNoZS5nZXQoa2V5KTtcclxuICAgIFxyXG4gICAgaWYgKCFlbnRyeSkge1xyXG4gICAgICB0aGlzLm1pc3NlcysrO1xyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhbnkgY2FjaGUgZm9yIHRoaXMgdXNlciAod2l0aCBkaWZmZXJlbnQgY29udGVudClcclxuICAgICAgY29uc3QgdXNlcktleXMgPSBBcnJheS5mcm9tKHRoaXMuY2FjaGUua2V5cygpKS5maWx0ZXIoayA9PiBrLnN0YXJ0c1dpdGgoYGFuYWx5c2lzOiR7dXNlcm5hbWUudG9Mb3dlckNhc2UoKX06YCkpO1xyXG4gICAgICBpZiAodXNlcktleXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBDYWNoZSBtaXNzIGZvciB1c2VyOiAke3VzZXJuYW1lfSAtIGNvbnRlbnQgaGFzIGNoYW5nZWQgKGhhc2g6ICR7Y29udGVudEhhc2h9KWApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENsZWFuIHVwIG9sZCBlbnRyaWVzIGZvciB0aGlzIHVzZXJcclxuICAgICAgICB1c2VyS2V5cy5mb3JFYWNoKG9sZEtleSA9PiB0aGlzLmNhY2hlLmRlbGV0ZShvbGRLZXkpKTtcclxuICAgICAgICB0aGlzLnNhdmVUb1N0b3JhZ2UoKTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChEYXRlLm5vdygpID4gZW50cnkuZXhwaXJlc0F0KSB7XHJcbiAgICAgIHRoaXMuY2FjaGUuZGVsZXRlKGtleSk7XHJcbiAgICAgIHRoaXMubWlzc2VzKys7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBDYWNoZSBleHBpcmVkIGZvciB1c2VyOiAke3VzZXJuYW1lfWApO1xyXG4gICAgICB0aGlzLnNhdmVUb1N0b3JhZ2UoKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHRoaXMuaGl0cysrO1xyXG4gICAgY29uc3QgYWdlID0gTWF0aC5yb3VuZCgoRGF0ZS5ub3coKSAtIGVudHJ5LnRpbWVzdGFtcCkgLyAoNjAgKiA2MCAqIDEwMDApKTtcclxuICAgIGNvbnNvbGUubG9nKGBDYWNoZSBoaXQgZm9yIHVzZXI6ICR7dXNlcm5hbWV9LCBhZ2U6ICR7YWdlfSBob3VycywgaGFzaDogJHtjb250ZW50SGFzaH1gKTtcclxuICAgIHJldHVybiBlbnRyeS5kYXRhO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYW5hbHlzaXMgaXMgY2FjaGVkIGFuZCBzdGlsbCB2YWxpZFxyXG4gICAqL1xyXG4gIGhhc1ZhbGlkQW5hbHlzaXModXNlcm5hbWU6IHN0cmluZywgY29tbWVudHM6IGFueVtdID0gW10sIHBvc3RzOiBhbnlbXSA9IFtdKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRBbmFseXNpcyh1c2VybmFtZSwgY29tbWVudHMsIHBvc3RzKSAhPT0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsZWFyIGNhY2hlIGZvciBzcGVjaWZpYyB1c2VyIChhbGwgY29udGVudCB2ZXJzaW9ucylcclxuICAgKi9cclxuICBjbGVhckFuYWx5c2lzKHVzZXJuYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICAgIGNvbnN0IHVzZXJLZXlzID0gQXJyYXkuZnJvbSh0aGlzLmNhY2hlLmtleXMoKSkuZmlsdGVyKGsgPT4gXHJcbiAgICAgIGsuc3RhcnRzV2l0aChgYW5hbHlzaXM6JHt1c2VybmFtZS50b0xvd2VyQ2FzZSgpfTpgKVxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgdXNlcktleXMuZm9yRWFjaChrZXkgPT4gdGhpcy5jYWNoZS5kZWxldGUoa2V5KSk7XHJcbiAgICBjb25zb2xlLmxvZyhgQ2xlYXJlZCAke3VzZXJLZXlzLmxlbmd0aH0gY2FjaGUgZW50cmllcyBmb3IgdXNlcjogJHt1c2VybmFtZX1gKTtcclxuICAgIHRoaXMuc2F2ZVRvU3RvcmFnZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xlYXIgYWxsIGNhY2hlZCBkYXRhXHJcbiAgICovXHJcbiAgY2xlYXJBbGwoKTogdm9pZCB7XHJcbiAgICB0aGlzLmNhY2hlLmNsZWFyKCk7XHJcbiAgICB0aGlzLmhpdHMgPSAwO1xyXG4gICAgdGhpcy5taXNzZXMgPSAwO1xyXG4gICAgY29uc29sZS5sb2coJ0NsZWFyZWQgYWxsIGNhY2hlZCBhbmFseXNlcycpO1xyXG4gICAgdGhpcy5zYXZlVG9TdG9yYWdlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgY29tcHJlaGVuc2l2ZSBjYWNoZSBzdGF0aXN0aWNzXHJcbiAgICovXHJcbiAgZ2V0U3RhdHMoKTogQ2FjaGVTdGF0cyB7XHJcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xyXG4gICAgbGV0IHZhbGlkRW50cmllcyA9IDA7XHJcbiAgICBsZXQgZXhwaXJlZEVudHJpZXMgPSAwO1xyXG4gICAgbGV0IHRvdGFsU2l6ZSA9IDA7XHJcbiAgICBcclxuICAgIHRoaXMuY2FjaGUuZm9yRWFjaChlbnRyeSA9PiB7XHJcbiAgICAgIGlmIChub3cgPD0gZW50cnkuZXhwaXJlc0F0KSB7XHJcbiAgICAgICAgdmFsaWRFbnRyaWVzKys7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZXhwaXJlZEVudHJpZXMrKztcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gRXN0aW1hdGUgc2l6ZSAocm91Z2ggYXBwcm94aW1hdGlvbilcclxuICAgICAgdG90YWxTaXplICs9IEpTT04uc3RyaW5naWZ5KGVudHJ5KS5sZW5ndGg7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgY29uc3QgdG90YWxSZXF1ZXN0cyA9IHRoaXMuaGl0cyArIHRoaXMubWlzc2VzO1xyXG4gICAgY29uc3QgaGl0UmF0ZSA9IHRvdGFsUmVxdWVzdHMgPiAwID8gKHRoaXMuaGl0cyAvIHRvdGFsUmVxdWVzdHMpICogMTAwIDogMDtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG90YWxFbnRyaWVzOiB0aGlzLmNhY2hlLnNpemUsXHJcbiAgICAgIHZhbGlkRW50cmllcyxcclxuICAgICAgZXhwaXJlZEVudHJpZXMsXHJcbiAgICAgIHRvdGFsU2l6ZSxcclxuICAgICAgaGl0UmF0ZVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCBjYWNoZSBlbnRyaWVzIGZvciBkZWJ1Z2dpbmdcclxuICAgKi9cclxuICBnZXREZWJ1Z0luZm8oKTogQXJyYXk8e1xyXG4gICAga2V5OiBzdHJpbmc7XHJcbiAgICB1c2VybmFtZTogc3RyaW5nO1xyXG4gICAgY29udGVudEhhc2g6IHN0cmluZztcclxuICAgIGFnZTogc3RyaW5nO1xyXG4gICAgc2l6ZTogbnVtYmVyO1xyXG4gICAgaXNFeHBpcmVkOiBib29sZWFuO1xyXG4gIH0+IHtcclxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICBcclxuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2FjaGUuZW50cmllcygpKS5tYXAoKFtrZXksIGVudHJ5XSkgPT4ge1xyXG4gICAgICBjb25zdCBwYXJ0cyA9IGtleS5zcGxpdCgnOicpO1xyXG4gICAgICBjb25zdCB1c2VybmFtZSA9IHBhcnRzWzFdIHx8ICd1bmtub3duJztcclxuICAgICAgY29uc3QgY29udGVudEhhc2ggPSBwYXJ0c1syXSB8fCAndW5rbm93bic7XHJcbiAgICAgIGNvbnN0IGFnZU1zID0gbm93IC0gZW50cnkudGltZXN0YW1wO1xyXG4gICAgICBjb25zdCBhZ2UgPSBhZ2VNcyA8IDYwMDAwID8gYCR7TWF0aC5yb3VuZChhZ2VNcyAvIDEwMDApfXNgIDpcclxuICAgICAgICAgICAgICAgICAgYWdlTXMgPCAzNjAwMDAwID8gYCR7TWF0aC5yb3VuZChhZ2VNcyAvIDYwMDAwKX1tYCA6XHJcbiAgICAgICAgICAgICAgICAgIGAke01hdGgucm91bmQoYWdlTXMgLyAzNjAwMDAwKX1oYDtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAga2V5LFxyXG4gICAgICAgIHVzZXJuYW1lLFxyXG4gICAgICAgIGNvbnRlbnRIYXNoLFxyXG4gICAgICAgIGFnZSxcclxuICAgICAgICBzaXplOiBKU09OLnN0cmluZ2lmeShlbnRyeSkubGVuZ3RoLFxyXG4gICAgICAgIGlzRXhwaXJlZDogbm93ID4gZW50cnkuZXhwaXJlc0F0XHJcbiAgICAgIH07XHJcbiAgICB9KS5zb3J0KChhLCBiKSA9PiBhLnVzZXJuYW1lLmxvY2FsZUNvbXBhcmUoYi51c2VybmFtZSkpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IGNhY2hlU2VydmljZSA9IG5ldyBDYWNoZVNlcnZpY2UoKTsiXSwibmFtZXMiOlsiQ2FjaGVTZXJ2aWNlIiwibG9hZEZyb21TdG9yYWdlIiwic3RvcmVkIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImRhdGEiLCJKU09OIiwicGFyc2UiLCJ2ZXJzaW9uIiwiQ0FDSEVfVkVSU0lPTiIsImNvbnNvbGUiLCJsb2ciLCJjbGVhckFsbCIsImVudHJpZXMiLCJrZXkiLCJlbnRyeSIsIk9iamVjdCIsImNhY2hlIiwic2V0Iiwic2l6ZSIsImNsZWFudXBFeHBpcmVkIiwiZXJyb3IiLCJ3YXJuIiwic2F2ZVRvU3RvcmFnZSIsImZyb21FbnRyaWVzIiwibGFzdFNhdmVkIiwiRGF0ZSIsIm5vdyIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJFcnJvciIsIm5hbWUiLCJldmljdE9sZGVzdCIsIk1hdGgiLCJmbG9vciIsInNldHVwUGVyaW9kaWNDbGVhbnVwIiwic2V0SW50ZXJ2YWwiLCJnZW5lcmF0ZUNvbnRlbnRIYXNoIiwiY29tbWVudHMiLCJwb3N0cyIsImxhdGVzdENvbW1lbnQiLCJsZW5ndGgiLCJtYXgiLCJtYXAiLCJjIiwiY3JlYXRlZF91dGMiLCJsYXRlc3RQb3N0IiwicCIsImxhdGVzdCIsImNvbnRlbnRTaWduYXR1cmUiLCJoYXNoIiwiaSIsImNoYXIiLCJjaGFyQ29kZUF0IiwiYWJzIiwidG9TdHJpbmciLCJnZXRBbmFseXNpc0tleSIsInVzZXJuYW1lIiwiY29udGVudEhhc2giLCJ0b0xvd2VyQ2FzZSIsImNvdW50IiwiQXJyYXkiLCJmcm9tIiwic29ydCIsImEiLCJiIiwidGltZXN0YW1wIiwibWluIiwiZGVsZXRlIiwiY2xlYW5lZENvdW50IiwiZm9yRWFjaCIsImV4cGlyZXNBdCIsInNldEFuYWx5c2lzIiwidHRsIiwiREVGQVVMVF9UVEwiLCJNQVhfQ0FDSEVfU0laRSIsInJvdW5kIiwiZ2V0QW5hbHlzaXMiLCJnZXQiLCJtaXNzZXMiLCJ1c2VyS2V5cyIsImtleXMiLCJmaWx0ZXIiLCJrIiwic3RhcnRzV2l0aCIsIm9sZEtleSIsImhpdHMiLCJhZ2UiLCJoYXNWYWxpZEFuYWx5c2lzIiwiY2xlYXJBbmFseXNpcyIsImNsZWFyIiwiZ2V0U3RhdHMiLCJ2YWxpZEVudHJpZXMiLCJleHBpcmVkRW50cmllcyIsInRvdGFsU2l6ZSIsInRvdGFsUmVxdWVzdHMiLCJoaXRSYXRlIiwidG90YWxFbnRyaWVzIiwiZ2V0RGVidWdJbmZvIiwicGFydHMiLCJzcGxpdCIsImFnZU1zIiwiaXNFeHBpcmVkIiwibG9jYWxlQ29tcGFyZSIsImNvbnN0cnVjdG9yIiwiTWFwIiwiY2FjaGVTZXJ2aWNlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/services/cacheService.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/lib/services/redditApi.ts":
/*!***************************************!*\
  !*** ./src/lib/services/redditApi.ts ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   redditApi: () => (/* binding */ redditApi)\n/* harmony export */ });\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var axios_retry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios-retry */ \"(app-pages-browser)/./node_modules/axios-retry/dist/esm/index.js\");\n\n\nclass RedditApiService {\n    setVerbose(verbose) {\n        this.verbose = verbose;\n    }\n    debug() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (this.verbose) {\n            console.log('[RedditAPI]', ...args);\n        }\n    }\n    async makeRequest(url) {\n        let source = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 'reddit';\n        try {\n            this.debug('Making request to:', url);\n            const response = await this.axiosInstance.get(url);\n            this.debug('Request successful:', {\n                url,\n                status: response.status\n            });\n            return response.data;\n        } catch (error) {\n            this.debug('Request failed:', {\n                url,\n                error: error instanceof Error ? error.message : 'Unknown error'\n            });\n            if (axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isAxiosError(error)) {\n                var _error_response, _error_response1, _error_response2, _error_response3;\n                if (((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 404) {\n                    throw new Error(source === 'reddit' ? 'User not found' : 'No data found');\n                } else if (((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.status) === 429) {\n                    throw new Error('Rate limit exceeded. Please try again later.');\n                } else if (((_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : _error_response2.status) === 503) {\n                    throw new Error('Service temporarily unavailable. Please try again later.');\n                } else if (((_error_response3 = error.response) === null || _error_response3 === void 0 ? void 0 : _error_response3.status) && error.response.status >= 500) {\n                    throw new Error(\"Server error occurred (\".concat(error.response.status, \"). Please try again.\"));\n                } else if (error.code === 'ECONNABORTED' || error.message.includes('timeout')) {\n                    throw new Error('Request timeout. Please try again.');\n                }\n            }\n            throw new Error(\"Failed to fetch data: \".concat(error instanceof Error ? error.message : 'Unknown error'));\n        }\n    }\n    delay(ms) {\n        return new Promise((resolve)=>setTimeout(resolve, ms));\n    }\n    // Streaming iterator for unlimited Reddit pagination\n    async *iterateComments(username) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const { maxItems = 10000, maxAge = 365 } = options;\n        let totalFetched = 0;\n        let after = null;\n        const cutoffDate = Date.now() / 1000 - maxAge * 24 * 60 * 60;\n        this.debug(\"Starting Reddit comment iteration for \".concat(username, \", max: \").concat(maxItems, \", maxAge: \").concat(maxAge, \" days\"));\n        // Phase 1: Reddit official API (newest ~1000 items)\n        while(totalFetched < maxItems){\n            try {\n                let url = \"\".concat(this.baseUrl, \"/user/\").concat(username, \"/comments.json?limit=100&sort=new\");\n                if (after) {\n                    url += \"&after=\".concat(after);\n                }\n                const data = await this.makeRequest(url, 'reddit');\n                if (!data.data || !data.data.children || data.data.children.length === 0) {\n                    this.debug('No more comments from Reddit API');\n                    break;\n                }\n                const batch = data.data.children.map((child)=>child.data).filter((comment)=>{\n                    return comment.body && comment.body !== '[deleted]' && comment.body !== '[removed]' && comment.body.length > 20 && comment.created_utc >= cutoffDate;\n                }).map((comment)=>({\n                        id: comment.id,\n                        body: comment.body,\n                        created_utc: comment.created_utc,\n                        subreddit: comment.subreddit,\n                        score: comment.score,\n                        permalink: comment.permalink,\n                        author: comment.author,\n                        link_title: comment.link_title\n                    }));\n                if (batch.length > 0) {\n                    yield batch;\n                    totalFetched += batch.length;\n                    this.debug(\"Reddit batch yielded: \".concat(batch.length, \", total: \").concat(totalFetched));\n                }\n                after = data.data.after;\n                if (!after) {\n                    this.debug('Reddit pagination complete');\n                    break;\n                }\n                await this.delay(1000); // Rate limiting\n            } catch (error) {\n                this.debug('Reddit API error:', error instanceof Error ? error.message : 'Unknown error');\n                break;\n            }\n        }\n        // Phase 2: Pushshift for historical data (if we need more and haven't hit limits)\n        if (totalFetched < maxItems && totalFetched < 8000) {\n            this.debug('Switching to Pushshift for historical data');\n            let before = Math.floor(Date.now() / 1000);\n            let pushShiftAttempts = 0;\n            const maxPushShiftAttempts = 8;\n            while(totalFetched < maxItems && pushShiftAttempts < maxPushShiftAttempts){\n                try {\n                    const url = \"\".concat(this.pushShiftUrl, \"/comment/search?author=\").concat(username, \"&size=500&before=\").concat(before, \"&sort=desc\");\n                    const data = await this.makeRequest(url, 'pushshift');\n                    if (!data.data || data.data.length === 0) {\n                        this.debug('No more comments from Pushshift');\n                        break;\n                    }\n                    const batch = data.data.filter((comment)=>{\n                        return comment.body && comment.body !== '[deleted]' && comment.body !== '[removed]' && comment.body.length > 20 && comment.created_utc >= cutoffDate;\n                    }).map((comment)=>({\n                            id: comment.id,\n                            body: comment.body,\n                            created_utc: comment.created_utc,\n                            subreddit: comment.subreddit,\n                            score: comment.score || 1,\n                            permalink: comment.permalink || \"/r/\".concat(comment.subreddit, \"/comments/\").concat(comment.link_id, \"/\").concat(comment.id, \"/\"),\n                            author: comment.author,\n                            link_title: comment.link_title\n                        }));\n                    if (batch.length > 0) {\n                        yield batch;\n                        totalFetched += batch.length;\n                        before = Math.min(...batch.map((c)=>c.created_utc)) - 1;\n                        this.debug(\"Pushshift batch yielded: \".concat(batch.length, \", total: \").concat(totalFetched));\n                    } else {\n                        break;\n                    }\n                    pushShiftAttempts++;\n                    await this.delay(2000); // Pushshift rate limiting\n                } catch (error) {\n                    this.debug('Pushshift error:', error instanceof Error ? error.message : 'Unknown error');\n                    break;\n                }\n            }\n        }\n        this.debug(\"Comment iteration complete: \".concat(totalFetched, \" total comments\"));\n    }\n    // Streaming iterator for posts\n    async *iteratePosts(username) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const { maxItems = 2000, maxAge = 365 } = options;\n        let totalFetched = 0;\n        let after = null;\n        const cutoffDate = Date.now() / 1000 - maxAge * 24 * 60 * 60;\n        this.debug(\"Starting Reddit post iteration for \".concat(username, \", max: \").concat(maxItems));\n        // Reddit API for posts\n        while(totalFetched < maxItems){\n            try {\n                let url = \"\".concat(this.baseUrl, \"/user/\").concat(username, \"/submitted.json?limit=100&sort=new\");\n                if (after) {\n                    url += \"&after=\".concat(after);\n                }\n                const data = await this.makeRequest(url, 'reddit');\n                if (!data.data || !data.data.children || data.data.children.length === 0) {\n                    break;\n                }\n                const batch = data.data.children.map((child)=>child.data).filter((post)=>{\n                    return post.selftext && post.selftext !== '[deleted]' && post.selftext !== '[removed]' && post.selftext.length > 20 && post.created_utc >= cutoffDate;\n                }).map((post)=>({\n                        id: post.id,\n                        title: post.title,\n                        selftext: post.selftext,\n                        created_utc: post.created_utc,\n                        subreddit: post.subreddit,\n                        score: post.score,\n                        permalink: post.permalink,\n                        author: post.author,\n                        num_comments: post.num_comments\n                    }));\n                if (batch.length > 0) {\n                    yield batch;\n                    totalFetched += batch.length;\n                }\n                after = data.data.after;\n                if (!after) break;\n                await this.delay(1000);\n            } catch (error) {\n                this.debug('Posts API error:', error instanceof Error ? error.message : 'Unknown error');\n                break;\n            }\n        }\n        this.debug(\"Post iteration complete: \".concat(totalFetched, \" total posts\"));\n    }\n    // Legacy methods for compatibility\n    async getUserInfo(username) {\n        const url = \"\".concat(this.baseUrl, \"/user/\").concat(username, \"/about.json\");\n        this.debug('Fetching user info for:', username);\n        const data = await this.makeRequest(url, 'reddit');\n        if (!data.data) {\n            throw new Error('User not found');\n        }\n        return {\n            name: data.data.name,\n            created_utc: data.data.created_utc,\n            comment_karma: data.data.comment_karma,\n            link_karma: data.data.link_karma,\n            total_karma: data.data.total_karma,\n            verified: data.data.verified,\n            is_gold: data.data.is_gold,\n            is_mod: data.data.is_mod\n        };\n    }\n    async getUserComments(username) {\n        let maxComments = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5000;\n        const comments = [];\n        for await (const batch of this.iterateComments(username, {\n            maxItems: maxComments\n        })){\n            comments.push(...batch);\n            if (comments.length >= maxComments) break;\n        }\n        return comments.slice(0, maxComments);\n    }\n    async getUserPosts(username) {\n        let maxPosts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2000;\n        const posts = [];\n        for await (const batch of this.iteratePosts(username, {\n            maxItems: maxPosts\n        })){\n            posts.push(...batch);\n            if (posts.length >= maxPosts) break;\n        }\n        return posts.slice(0, maxPosts);\n    }\n    async getFullUserData(username) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        try {\n            this.debug('Fetching comprehensive user data for:', username);\n            // Fetch user info first\n            const user = await this.getUserInfo(username);\n            // Stream all content\n            const comments = [];\n            const posts = [];\n            // Collect comments\n            for await (const batch of this.iterateComments(username, options)){\n                comments.push(...batch);\n                if (comments.length >= (options.maxItems || 5000)) break;\n            }\n            // Collect posts\n            for await (const batch of this.iteratePosts(username, options)){\n                posts.push(...batch);\n                if (posts.length >= 1000) break;\n            }\n            this.debug('Comprehensive data complete:', {\n                username,\n                comments: comments.length,\n                posts: posts.length,\n                totalContent: comments.length + posts.length\n            });\n            return {\n                user,\n                comments,\n                posts\n            };\n        } catch (error) {\n            this.debug('Failed to fetch comprehensive user data:', error instanceof Error ? error.message : 'Unknown error');\n            throw error;\n        }\n    }\n    async getUserPreview(username) {\n        try {\n            const user = await this.getUserInfo(username);\n            // Get a small sample to check for recent activity\n            const sampleComments = [];\n            let batchCount = 0;\n            for await (const batch of this.iterateComments(username, {\n                maxItems: 20\n            })){\n                sampleComments.push(...batch);\n                batchCount++;\n                if (batchCount >= 1) break; // Just first batch for preview\n            }\n            const accountAge = Math.floor((Date.now() / 1000 - user.created_utc) / (24 * 60 * 60));\n            const ageString = accountAge < 30 ? \"\".concat(accountAge, \" days\") : accountAge < 365 ? \"\".concat(Math.floor(accountAge / 30), \" months\") : \"\".concat(Math.floor(accountAge / 365), \" years\");\n            // Better estimation based on karma and account age\n            const dailyKarma = user.comment_karma / Math.max(accountAge, 1);\n            const estimatedComments = Math.min(Math.max(dailyKarma * 2, 100), 8000);\n            return {\n                exists: true,\n                karma: user.total_karma,\n                accountAge: ageString,\n                recentActivity: sampleComments.length > 0,\n                estimatedComments: Math.floor(estimatedComments)\n            };\n        } catch (e) {\n            return {\n                exists: false,\n                karma: 0,\n                accountAge: 'Unknown',\n                recentActivity: false,\n                estimatedComments: 0\n            };\n        }\n    }\n    constructor(){\n        this.baseUrl = '/api/reddit';\n        this.pushShiftUrl = 'https://api.pushshift.io/reddit';\n        this.verbose = false;\n        this.axiosInstance = axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n            timeout: 30000\n        });\n        // Enhanced retry configuration\n        (0,axios_retry__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this.axiosInstance, {\n            retries: 3,\n            retryDelay: axios_retry__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exponentialDelay,\n            retryCondition: (error)=>{\n                var _error_response, // Reddit overload\n                _error_response1, // Bad gateway\n                _error_response2;\n                return axios_retry__WEBPACK_IMPORTED_MODULE_0__[\"default\"].isNetworkOrIdempotentRequestError(error) || error.code === 'ECONNRESET' || error.code === 'ENOTFOUND' || error.code === 'ECONNABORTED' || error.message.includes('socket hang up') || ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.status) === 503 || ((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : _error_response1.status) === 502 || ((_error_response2 = error.response) === null || _error_response2 === void 0 ? void 0 : _error_response2.status) === 504; // Gateway timeout\n            },\n            onRetry: (retryCount, error, requestConfig)=>{\n                if (this.verbose) {\n                    console.log(\"Retrying request (attempt \".concat(retryCount, \"):\"), requestConfig.url);\n                }\n            }\n        });\n    }\n}\nconst redditApi = new RedditApiService();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2VydmljZXMvcmVkZGl0QXBpLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEwQjtBQUNXO0FBMENyQyxNQUFNRTtJQWlDSkMsV0FBV0MsT0FBZ0IsRUFBRTtRQUMzQixJQUFJLENBQUNBLE9BQU8sR0FBR0E7SUFDakI7SUFFUUMsUUFBc0I7UUFBaEI7WUFBR0MsS0FBSCx1QkFBYzs7UUFDMUIsSUFBSSxJQUFJLENBQUNGLE9BQU8sRUFBRTtZQUNoQkcsUUFBUUMsR0FBRyxDQUFDLGtCQUFrQkY7UUFDaEM7SUFDRjtJQUVBLE1BQWNHLFlBQVlDLEdBQVcsRUFBMkQ7WUFBekRDLFNBQUFBLGlFQUFpQztRQUN0RSxJQUFJO1lBQ0YsSUFBSSxDQUFDTixLQUFLLENBQUMsc0JBQXNCSztZQUNqQyxNQUFNRSxXQUFXLE1BQU0sSUFBSSxDQUFDQyxhQUFhLENBQUNDLEdBQUcsQ0FBQ0o7WUFDOUMsSUFBSSxDQUFDTCxLQUFLLENBQUMsdUJBQXVCO2dCQUFFSztnQkFBS0ssUUFBUUgsU0FBU0csTUFBTTtZQUFDO1lBQ2pFLE9BQU9ILFNBQVNJLElBQUk7UUFDdEIsRUFBRSxPQUFPQyxPQUFPO1lBQ2QsSUFBSSxDQUFDWixLQUFLLENBQUMsbUJBQW1CO2dCQUFFSztnQkFBS08sT0FBT0EsaUJBQWlCQyxRQUFRRCxNQUFNRSxPQUFPLEdBQUc7WUFBZ0I7WUFFckcsSUFBSW5CLDZDQUFLQSxDQUFDb0IsWUFBWSxDQUFDSCxRQUFRO29CQUN6QkEsaUJBRU9BLGtCQUVBQSxrQkFFQUE7Z0JBTlgsSUFBSUEsRUFBQUEsa0JBQUFBLE1BQU1MLFFBQVEsY0FBZEssc0NBQUFBLGdCQUFnQkYsTUFBTSxNQUFLLEtBQUs7b0JBQ2xDLE1BQU0sSUFBSUcsTUFBTVAsV0FBVyxXQUFXLG1CQUFtQjtnQkFDM0QsT0FBTyxJQUFJTSxFQUFBQSxtQkFBQUEsTUFBTUwsUUFBUSxjQUFkSyx1Q0FBQUEsaUJBQWdCRixNQUFNLE1BQUssS0FBSztv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a0MsY0FBYztnQkFDaERBO2dCQVBQLE9BQU9oQixxRkFBNEMsQ0FBQ2dCLFVBQzdDQSxNQUFNSSxJQUFJLEtBQUssZ0JBQ2ZKLE1BQU1JLElBQUksS0FBSyxlQUNmSixNQUFNSSxJQUFJLEtBQUssa0JBQ2ZKLE1BQU1FLE9BQU8sQ0FBQ0csUUFBUSxDQUFDLHFCQUN2QkwsRUFBQUEsa0JBQUFBLE1BQU1MLFFBQVEsY0FBZEssc0NBQUFBLGdCQUFnQkYsTUFBTSxNQUFLLE9BQzNCRSxFQUFBQSxtQkFBQUEsTUFBTUwsUUFBUSxjQUFkSyx1Q0FBQUEsaUJBQWdCRixNQUFNLE1BQUssT0FDM0JFLEVBQUFBLG1CQUFBQSxNQUFNTCxRQUFRLGNBQWRLLHVDQUFBQSxpQkFBZ0JGLE1BQU0sTUFBSyxLQUFPLGtCQUFrQjtZQUM3RDtZQUNBMkYsU0FBUyxDQUFDQyxZQUFZMUYsT0FBTzJGO2dCQUMzQixJQUFJLElBQUksQ0FBQ3hHLE9BQU8sRUFBRTtvQkFDaEJHLFFBQVFDLEdBQUcsQ0FBQyw2QkFBd0MsT0FBWG1HLFlBQVcsT0FBS0MsY0FBY2xHLEdBQUc7Z0JBQzVFO1lBQ0Y7UUFDRjtJQUNGO0FBcVdGO0FBRU8sTUFBTW1HLFlBQVksSUFBSTNHLG1CQUFtQiIsInNvdXJjZXMiOlsiRDpcXGNvZGluZ1xcbGF1bmNoXFx0aG91Z2h0UG9saWNlXFxzcmNcXGxpYlxcc2VydmljZXNcXHJlZGRpdEFwaS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXhpb3MgZnJvbSAnYXhpb3MnO1xyXG5pbXBvcnQgYXhpb3NSZXRyeSBmcm9tICdheGlvcy1yZXRyeSc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFJlZGRpdENvbW1lbnQge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgYm9keTogc3RyaW5nO1xyXG4gIGNyZWF0ZWRfdXRjOiBudW1iZXI7XHJcbiAgc3VicmVkZGl0OiBzdHJpbmc7XHJcbiAgc2NvcmU6IG51bWJlcjtcclxuICBwZXJtYWxpbms6IHN0cmluZztcclxuICBhdXRob3I6IHN0cmluZztcclxuICBsaW5rX3RpdGxlPzogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFJlZGRpdFBvc3Qge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgdGl0bGU6IHN0cmluZztcclxuICBzZWxmdGV4dDogc3RyaW5nO1xyXG4gIGNyZWF0ZWRfdXRjOiBudW1iZXI7XHJcbiAgc3VicmVkZGl0OiBzdHJpbmc7XHJcbiAgc2NvcmU6IG51bWJlcjtcclxuICBwZXJtYWxpbms6IHN0cmluZztcclxuICBhdXRob3I6IHN0cmluZztcclxuICBudW1fY29tbWVudHM6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBSZWRkaXRVc2VyIHtcclxuICBuYW1lOiBzdHJpbmc7XHJcbiAgY3JlYXRlZF91dGM6IG51bWJlcjtcclxuICBjb21tZW50X2thcm1hOiBudW1iZXI7XHJcbiAgbGlua19rYXJtYTogbnVtYmVyO1xyXG4gIHRvdGFsX2thcm1hOiBudW1iZXI7XHJcbiAgdmVyaWZpZWQ6IGJvb2xlYW47XHJcbiAgaXNfZ29sZDogYm9vbGVhbjtcclxuICBpc19tb2Q6IGJvb2xlYW47XHJcbn1cclxuXHJcbmludGVyZmFjZSBGZXRjaE9wdGlvbnMge1xyXG4gIG1heEl0ZW1zPzogbnVtYmVyO1xyXG4gIG1heEFnZT86IG51bWJlcjsgLy8gZGF5c1xyXG4gIHZlcmJvc2U/OiBib29sZWFuO1xyXG59XHJcblxyXG5jbGFzcyBSZWRkaXRBcGlTZXJ2aWNlIHtcclxuICBwcml2YXRlIGJhc2VVcmwgPSAnL2FwaS9yZWRkaXQnO1xyXG4gIHByaXZhdGUgcHVzaFNoaWZ0VXJsID0gJ2h0dHBzOi8vYXBpLnB1c2hzaGlmdC5pby9yZWRkaXQnO1xyXG4gIHByaXZhdGUgYXhpb3NJbnN0YW5jZTtcclxuICBwcml2YXRlIHZlcmJvc2UgPSBmYWxzZTtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLmF4aW9zSW5zdGFuY2UgPSBheGlvcy5jcmVhdGUoe1xyXG4gICAgICB0aW1lb3V0OiAzMDAwMCwgLy8gSW5jcmVhc2VkIGZvciBQdXNoc2hpZnRcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEVuaGFuY2VkIHJldHJ5IGNvbmZpZ3VyYXRpb25cclxuICAgIGF4aW9zUmV0cnkodGhpcy5heGlvc0luc3RhbmNlLCB7XHJcbiAgICAgIHJldHJpZXM6IDMsXHJcbiAgICAgIHJldHJ5RGVsYXk6IGF4aW9zUmV0cnkuZXhwb25lbnRpYWxEZWxheSxcclxuICAgICAgcmV0cnlDb25kaXRpb246IChlcnJvcikgPT4ge1xyXG4gICAgICAgIHJldHVybiBheGlvc1JldHJ5LmlzTmV0d29ya09ySWRlbXBvdGVudFJlcXVlc3RFcnJvcihlcnJvcikgfHxcclxuICAgICAgICAgICAgICAgZXJyb3IuY29kZSA9PT0gJ0VDT05OUkVTRVQnIHx8XHJcbiAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPT09ICdFTk9URk9VTkQnIHx8XHJcbiAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPT09ICdFQ09OTkFCT1JURUQnIHx8XHJcbiAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ3NvY2tldCBoYW5nIHVwJykgfHxcclxuICAgICAgICAgICAgICAgZXJyb3IucmVzcG9uc2U/LnN0YXR1cyA9PT0gNTAzIHx8IC8vIFJlZGRpdCBvdmVybG9hZFxyXG4gICAgICAgICAgICAgICBlcnJvci5yZXNwb25zZT8uc3RhdHVzID09PSA1MDIgfHwgLy8gQmFkIGdhdGV3YXlcclxuICAgICAgICAgICAgICAgZXJyb3IucmVzcG9uc2U/LnN0YXR1cyA9PT0gNTA0OyAgIC8vIEdhdGV3YXkgdGltZW91dFxyXG4gICAgICB9LFxyXG4gICAgICBvblJldHJ5OiAocmV0cnlDb3VudCwgZXJyb3IsIHJlcXVlc3RDb25maWcpID0+IHtcclxuICAgICAgICBpZiAodGhpcy52ZXJib3NlKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgUmV0cnlpbmcgcmVxdWVzdCAoYXR0ZW1wdCAke3JldHJ5Q291bnR9KTpgLCByZXF1ZXN0Q29uZmlnLnVybCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBzZXRWZXJib3NlKHZlcmJvc2U6IGJvb2xlYW4pIHtcclxuICAgIHRoaXMudmVyYm9zZSA9IHZlcmJvc2U7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGRlYnVnKC4uLmFyZ3M6IGFueVtdKSB7XHJcbiAgICBpZiAodGhpcy52ZXJib3NlKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdbUmVkZGl0QVBJXScsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBtYWtlUmVxdWVzdCh1cmw6IHN0cmluZywgc291cmNlOiAncmVkZGl0JyB8ICdwdXNoc2hpZnQnID0gJ3JlZGRpdCcpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgdGhpcy5kZWJ1ZygnTWFraW5nIHJlcXVlc3QgdG86JywgdXJsKTtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmF4aW9zSW5zdGFuY2UuZ2V0KHVybCk7XHJcbiAgICAgIHRoaXMuZGVidWcoJ1JlcXVlc3Qgc3VjY2Vzc2Z1bDonLCB7IHVybCwgc3RhdHVzOiByZXNwb25zZS5zdGF0dXMgfSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5kZWJ1ZygnUmVxdWVzdCBmYWlsZWQ6JywgeyB1cmwsIGVycm9yOiBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJyB9KTtcclxuICAgICAgXHJcbiAgICAgIGlmIChheGlvcy5pc0F4aW9zRXJyb3IoZXJyb3IpKSB7XHJcbiAgICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQwNCkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHNvdXJjZSA9PT0gJ3JlZGRpdCcgPyAnVXNlciBub3QgZm91bmQnIDogJ05vIGRhdGEgZm91bmQnKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDQyOSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSYXRlIGxpbWl0IGV4Y2VlZGVkLiBQbGVhc2UgdHJ5IGFnYWluIGxhdGVyLicpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IucmVzcG9uc2U/LnN0YXR1cyA9PT0gNTAzKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZpY2UgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChlcnJvci5yZXNwb25zZT8uc3RhdHVzICYmIGVycm9yLnJlc3BvbnNlLnN0YXR1cyA+PSA1MDApIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmVyIGVycm9yIG9jY3VycmVkICgke2Vycm9yLnJlc3BvbnNlLnN0YXR1c30pLiBQbGVhc2UgdHJ5IGFnYWluLmApO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZXJyb3IuY29kZSA9PT0gJ0VDT05OQUJPUlRFRCcgfHwgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygndGltZW91dCcpKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgdGltZW91dC4gUGxlYXNlIHRyeSBhZ2Fpbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmV0Y2ggZGF0YTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yJ31gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZGVsYXkobXM6IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xyXG4gIH1cclxuXHJcbiAgLy8gU3RyZWFtaW5nIGl0ZXJhdG9yIGZvciB1bmxpbWl0ZWQgUmVkZGl0IHBhZ2luYXRpb25cclxuICBhc3luYyogaXRlcmF0ZUNvbW1lbnRzKHVzZXJuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IEZldGNoT3B0aW9ucyA9IHt9KTogQXN5bmNHZW5lcmF0b3I8UmVkZGl0Q29tbWVudFtdLCB2b2lkLCB1bmtub3duPiB7XHJcbiAgICBjb25zdCB7IG1heEl0ZW1zID0gMTAwMDAsIG1heEFnZSA9IDM2NSB9ID0gb3B0aW9ucztcclxuICAgIGxldCB0b3RhbEZldGNoZWQgPSAwO1xyXG4gICAgbGV0IGFmdGVyOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuICAgIGNvbnN0IGN1dG9mZkRhdGUgPSBEYXRlLm5vdygpIC8gMTAwMCAtIChtYXhBZ2UgKiAyNCAqIDYwICogNjApO1xyXG5cclxuICAgIHRoaXMuZGVidWcoYFN0YXJ0aW5nIFJlZGRpdCBjb21tZW50IGl0ZXJhdGlvbiBmb3IgJHt1c2VybmFtZX0sIG1heDogJHttYXhJdGVtc30sIG1heEFnZTogJHttYXhBZ2V9IGRheXNgKTtcclxuXHJcbiAgICAvLyBQaGFzZSAxOiBSZWRkaXQgb2ZmaWNpYWwgQVBJIChuZXdlc3QgfjEwMDAgaXRlbXMpXHJcbiAgICB3aGlsZSAodG90YWxGZXRjaGVkIDwgbWF4SXRlbXMpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsZXQgdXJsID0gYCR7dGhpcy5iYXNlVXJsfS91c2VyLyR7dXNlcm5hbWV9L2NvbW1lbnRzLmpzb24/bGltaXQ9MTAwJnNvcnQ9bmV3YDtcclxuICAgICAgICBpZiAoYWZ0ZXIpIHtcclxuICAgICAgICAgIHVybCArPSBgJmFmdGVyPSR7YWZ0ZXJ9YDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KHVybCwgJ3JlZGRpdCcpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICghZGF0YS5kYXRhIHx8ICFkYXRhLmRhdGEuY2hpbGRyZW4gfHwgZGF0YS5kYXRhLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgdGhpcy5kZWJ1ZygnTm8gbW9yZSBjb21tZW50cyBmcm9tIFJlZGRpdCBBUEknKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgYmF0Y2ggPSBkYXRhLmRhdGEuY2hpbGRyZW5cclxuICAgICAgICAgIC5tYXAoKGNoaWxkOiBhbnkpID0+IGNoaWxkLmRhdGEpXHJcbiAgICAgICAgICAuZmlsdGVyKChjb21tZW50OiBhbnkpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnQuYm9keSAmJiBcclxuICAgICAgICAgICAgICAgICAgIGNvbW1lbnQuYm9keSAhPT0gJ1tkZWxldGVkXScgJiYgXHJcbiAgICAgICAgICAgICAgICAgICBjb21tZW50LmJvZHkgIT09ICdbcmVtb3ZlZF0nICYmXHJcbiAgICAgICAgICAgICAgICAgICBjb21tZW50LmJvZHkubGVuZ3RoID4gMjAgJiZcclxuICAgICAgICAgICAgICAgICAgIGNvbW1lbnQuY3JlYXRlZF91dGMgPj0gY3V0b2ZmRGF0ZTtcclxuICAgICAgICAgIH0pXHJcbiAgICAgICAgICAubWFwKChjb21tZW50OiBhbnkpID0+ICh7XHJcbiAgICAgICAgICAgIGlkOiBjb21tZW50LmlkLFxyXG4gICAgICAgICAgICBib2R5OiBjb21tZW50LmJvZHksXHJcbiAgICAgICAgICAgIGNyZWF0ZWRfdXRjOiBjb21tZW50LmNyZWF0ZWRfdXRjLFxyXG4gICAgICAgICAgICBzdWJyZWRkaXQ6IGNvbW1lbnQuc3VicmVkZGl0LFxyXG4gICAgICAgICAgICBzY29yZTogY29tbWVudC5zY29yZSxcclxuICAgICAgICAgICAgcGVybWFsaW5rOiBjb21tZW50LnBlcm1hbGluayxcclxuICAgICAgICAgICAgYXV0aG9yOiBjb21tZW50LmF1dGhvcixcclxuICAgICAgICAgICAgbGlua190aXRsZTogY29tbWVudC5saW5rX3RpdGxlLFxyXG4gICAgICAgICAgfSkpO1xyXG5cclxuICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgeWllbGQgYmF0Y2g7XHJcbiAgICAgICAgICB0b3RhbEZldGNoZWQgKz0gYmF0Y2gubGVuZ3RoO1xyXG4gICAgICAgICAgdGhpcy5kZWJ1ZyhgUmVkZGl0IGJhdGNoIHlpZWxkZWQ6ICR7YmF0Y2gubGVuZ3RofSwgdG90YWw6ICR7dG90YWxGZXRjaGVkfWApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYWZ0ZXIgPSBkYXRhLmRhdGEuYWZ0ZXI7XHJcbiAgICAgICAgaWYgKCFhZnRlcikge1xyXG4gICAgICAgICAgdGhpcy5kZWJ1ZygnUmVkZGl0IHBhZ2luYXRpb24gY29tcGxldGUnKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5kZWxheSgxMDAwKTsgLy8gUmF0ZSBsaW1pdGluZ1xyXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIHRoaXMuZGVidWcoJ1JlZGRpdCBBUEkgZXJyb3I6JywgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUGhhc2UgMjogUHVzaHNoaWZ0IGZvciBoaXN0b3JpY2FsIGRhdGEgKGlmIHdlIG5lZWQgbW9yZSBhbmQgaGF2ZW4ndCBoaXQgbGltaXRzKVxyXG4gICAgaWYgKHRvdGFsRmV0Y2hlZCA8IG1heEl0ZW1zICYmIHRvdGFsRmV0Y2hlZCA8IDgwMDApIHsgLy8gUHVzaHNoaWZ0IHByYWN0aWNhbCBsaW1pdFxyXG4gICAgICB0aGlzLmRlYnVnKCdTd2l0Y2hpbmcgdG8gUHVzaHNoaWZ0IGZvciBoaXN0b3JpY2FsIGRhdGEnKTtcclxuICAgICAgXHJcbiAgICAgIGxldCBiZWZvcmUgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcclxuICAgICAgbGV0IHB1c2hTaGlmdEF0dGVtcHRzID0gMDtcclxuICAgICAgY29uc3QgbWF4UHVzaFNoaWZ0QXR0ZW1wdHMgPSA4O1xyXG5cclxuICAgICAgd2hpbGUgKHRvdGFsRmV0Y2hlZCA8IG1heEl0ZW1zICYmIHB1c2hTaGlmdEF0dGVtcHRzIDwgbWF4UHVzaFNoaWZ0QXR0ZW1wdHMpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5wdXNoU2hpZnRVcmx9L2NvbW1lbnQvc2VhcmNoP2F1dGhvcj0ke3VzZXJuYW1lfSZzaXplPTUwMCZiZWZvcmU9JHtiZWZvcmV9JnNvcnQ9ZGVzY2A7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KHVybCwgJ3B1c2hzaGlmdCcpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoIWRhdGEuZGF0YSB8fCBkYXRhLmRhdGEubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVidWcoJ05vIG1vcmUgY29tbWVudHMgZnJvbSBQdXNoc2hpZnQnKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgY29uc3QgYmF0Y2ggPSBkYXRhLmRhdGFcclxuICAgICAgICAgICAgLmZpbHRlcigoY29tbWVudDogYW55KSA9PiB7XHJcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbW1lbnQuYm9keSAmJiBcclxuICAgICAgICAgICAgICAgICAgICAgY29tbWVudC5ib2R5ICE9PSAnW2RlbGV0ZWRdJyAmJiBcclxuICAgICAgICAgICAgICAgICAgICAgY29tbWVudC5ib2R5ICE9PSAnW3JlbW92ZWRdJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICBjb21tZW50LmJvZHkubGVuZ3RoID4gMjAgJiZcclxuICAgICAgICAgICAgICAgICAgICAgY29tbWVudC5jcmVhdGVkX3V0YyA+PSBjdXRvZmZEYXRlO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAubWFwKChjb21tZW50OiBhbnkpID0+ICh7XHJcbiAgICAgICAgICAgICAgaWQ6IGNvbW1lbnQuaWQsXHJcbiAgICAgICAgICAgICAgYm9keTogY29tbWVudC5ib2R5LFxyXG4gICAgICAgICAgICAgIGNyZWF0ZWRfdXRjOiBjb21tZW50LmNyZWF0ZWRfdXRjLFxyXG4gICAgICAgICAgICAgIHN1YnJlZGRpdDogY29tbWVudC5zdWJyZWRkaXQsXHJcbiAgICAgICAgICAgICAgc2NvcmU6IGNvbW1lbnQuc2NvcmUgfHwgMSxcclxuICAgICAgICAgICAgICBwZXJtYWxpbms6IGNvbW1lbnQucGVybWFsaW5rIHx8IGAvci8ke2NvbW1lbnQuc3VicmVkZGl0fS9jb21tZW50cy8ke2NvbW1lbnQubGlua19pZH0vJHtjb21tZW50LmlkfS9gLFxyXG4gICAgICAgICAgICAgIGF1dGhvcjogY29tbWVudC5hdXRob3IsXHJcbiAgICAgICAgICAgICAgbGlua190aXRsZTogY29tbWVudC5saW5rX3RpdGxlLFxyXG4gICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgICAgaWYgKGJhdGNoLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgeWllbGQgYmF0Y2g7XHJcbiAgICAgICAgICAgIHRvdGFsRmV0Y2hlZCArPSBiYXRjaC5sZW5ndGg7XHJcbiAgICAgICAgICAgIGJlZm9yZSA9IE1hdGgubWluKC4uLmJhdGNoLm1hcCgoYzogYW55KSA9PiBjLmNyZWF0ZWRfdXRjKSkgLSAxO1xyXG4gICAgICAgICAgICB0aGlzLmRlYnVnKGBQdXNoc2hpZnQgYmF0Y2ggeWllbGRlZDogJHtiYXRjaC5sZW5ndGh9LCB0b3RhbDogJHt0b3RhbEZldGNoZWR9YCk7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBwdXNoU2hpZnRBdHRlbXB0cysrO1xyXG4gICAgICAgICAgYXdhaXQgdGhpcy5kZWxheSgyMDAwKTsgLy8gUHVzaHNoaWZ0IHJhdGUgbGltaXRpbmdcclxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgdGhpcy5kZWJ1ZygnUHVzaHNoaWZ0IGVycm9yOicsIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogJ1Vua25vd24gZXJyb3InKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuZGVidWcoYENvbW1lbnQgaXRlcmF0aW9uIGNvbXBsZXRlOiAke3RvdGFsRmV0Y2hlZH0gdG90YWwgY29tbWVudHNgKTtcclxuICB9XHJcblxyXG4gIC8vIFN0cmVhbWluZyBpdGVyYXRvciBmb3IgcG9zdHNcclxuICBhc3luYyogaXRlcmF0ZVBvc3RzKHVzZXJuYW1lOiBzdHJpbmcsIG9wdGlvbnM6IEZldGNoT3B0aW9ucyA9IHt9KTogQXN5bmNHZW5lcmF0b3I8UmVkZGl0UG9zdFtdLCB2b2lkLCB1bmtub3duPiB7XHJcbiAgICBjb25zdCB7IG1heEl0ZW1zID0gMjAwMCwgbWF4QWdlID0gMzY1IH0gPSBvcHRpb25zO1xyXG4gICAgbGV0IHRvdGFsRmV0Y2hlZCA9IDA7XHJcbiAgICBsZXQgYWZ0ZXI6IHN0cmluZyB8IG51bGwgPSBudWxsO1xyXG4gICAgY29uc3QgY3V0b2ZmRGF0ZSA9IERhdGUubm93KCkgLyAxMDAwIC0gKG1heEFnZSAqIDI0ICogNjAgKiA2MCk7XHJcblxyXG4gICAgdGhpcy5kZWJ1ZyhgU3RhcnRpbmcgUmVkZGl0IHBvc3QgaXRlcmF0aW9uIGZvciAke3VzZXJuYW1lfSwgbWF4OiAke21heEl0ZW1zfWApO1xyXG5cclxuICAgIC8vIFJlZGRpdCBBUEkgZm9yIHBvc3RzXHJcbiAgICB3aGlsZSAodG90YWxGZXRjaGVkIDwgbWF4SXRlbXMpIHtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICBsZXQgdXJsID0gYCR7dGhpcy5iYXNlVXJsfS91c2VyLyR7dXNlcm5hbWV9L3N1Ym1pdHRlZC5qc29uP2xpbWl0PTEwMCZzb3J0PW5ld2A7XHJcbiAgICAgICAgaWYgKGFmdGVyKSB7XHJcbiAgICAgICAgICB1cmwgKz0gYCZhZnRlcj0ke2FmdGVyfWA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5tYWtlUmVxdWVzdCh1cmwsICdyZWRkaXQnKTtcclxuICAgICAgICBcclxuICAgICAgICBpZiAoIWRhdGEuZGF0YSB8fCAhZGF0YS5kYXRhLmNoaWxkcmVuIHx8IGRhdGEuZGF0YS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgYmF0Y2ggPSBkYXRhLmRhdGEuY2hpbGRyZW5cclxuICAgICAgICAgIC5tYXAoKGNoaWxkOiBhbnkpID0+IGNoaWxkLmRhdGEpXHJcbiAgICAgICAgICAuZmlsdGVyKChwb3N0OiBhbnkpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHBvc3Quc2VsZnRleHQgJiYgXHJcbiAgICAgICAgICAgICAgICAgICBwb3N0LnNlbGZ0ZXh0ICE9PSAnW2RlbGV0ZWRdJyAmJiBcclxuICAgICAgICAgICAgICAgICAgIHBvc3Quc2VsZnRleHQgIT09ICdbcmVtb3ZlZF0nICYmXHJcbiAgICAgICAgICAgICAgICAgICBwb3N0LnNlbGZ0ZXh0Lmxlbmd0aCA+IDIwICYmXHJcbiAgICAgICAgICAgICAgICAgICBwb3N0LmNyZWF0ZWRfdXRjID49IGN1dG9mZkRhdGU7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgLm1hcCgocG9zdDogYW55KSA9PiAoe1xyXG4gICAgICAgICAgICBpZDogcG9zdC5pZCxcclxuICAgICAgICAgICAgdGl0bGU6IHBvc3QudGl0bGUsXHJcbiAgICAgICAgICAgIHNlbGZ0ZXh0OiBwb3N0LnNlbGZ0ZXh0LFxyXG4gICAgICAgICAgICBjcmVhdGVkX3V0YzogcG9zdC5jcmVhdGVkX3V0YyxcclxuICAgICAgICAgICAgc3VicmVkZGl0OiBwb3N0LnN1YnJlZGRpdCxcclxuICAgICAgICAgICAgc2NvcmU6IHBvc3Quc2NvcmUsXHJcbiAgICAgICAgICAgIHBlcm1hbGluazogcG9zdC5wZXJtYWxpbmssXHJcbiAgICAgICAgICAgIGF1dGhvcjogcG9zdC5hdXRob3IsXHJcbiAgICAgICAgICAgIG51bV9jb21tZW50czogcG9zdC5udW1fY29tbWVudHMsXHJcbiAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgIGlmIChiYXRjaC5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICB5aWVsZCBiYXRjaDtcclxuICAgICAgICAgIHRvdGFsRmV0Y2hlZCArPSBiYXRjaC5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBhZnRlciA9IGRhdGEuZGF0YS5hZnRlcjtcclxuICAgICAgICBpZiAoIWFmdGVyKSBicmVhaztcclxuXHJcbiAgICAgICAgYXdhaXQgdGhpcy5kZWxheSgxMDAwKTtcclxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICB0aGlzLmRlYnVnKCdQb3N0cyBBUEkgZXJyb3I6JywgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5kZWJ1ZyhgUG9zdCBpdGVyYXRpb24gY29tcGxldGU6ICR7dG90YWxGZXRjaGVkfSB0b3RhbCBwb3N0c2ApO1xyXG4gIH1cclxuXHJcbiAgLy8gTGVnYWN5IG1ldGhvZHMgZm9yIGNvbXBhdGliaWxpdHlcclxuICBhc3luYyBnZXRVc2VySW5mbyh1c2VybmFtZTogc3RyaW5nKTogUHJvbWlzZTxSZWRkaXRVc2VyPiB7XHJcbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9L3VzZXIvJHt1c2VybmFtZX0vYWJvdXQuanNvbmA7XHJcbiAgICB0aGlzLmRlYnVnKCdGZXRjaGluZyB1c2VyIGluZm8gZm9yOicsIHVzZXJuYW1lKTtcclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLm1ha2VSZXF1ZXN0KHVybCwgJ3JlZGRpdCcpO1xyXG4gICAgXHJcbiAgICBpZiAoIWRhdGEuZGF0YSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzZXIgbm90IGZvdW5kJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZTogZGF0YS5kYXRhLm5hbWUsXHJcbiAgICAgIGNyZWF0ZWRfdXRjOiBkYXRhLmRhdGEuY3JlYXRlZF91dGMsXHJcbiAgICAgIGNvbW1lbnRfa2FybWE6IGRhdGEuZGF0YS5jb21tZW50X2thcm1hLFxyXG4gICAgICBsaW5rX2thcm1hOiBkYXRhLmRhdGEubGlua19rYXJtYSxcclxuICAgICAgdG90YWxfa2FybWE6IGRhdGEuZGF0YS50b3RhbF9rYXJtYSxcclxuICAgICAgdmVyaWZpZWQ6IGRhdGEuZGF0YS52ZXJpZmllZCxcclxuICAgICAgaXNfZ29sZDogZGF0YS5kYXRhLmlzX2dvbGQsXHJcbiAgICAgIGlzX21vZDogZGF0YS5kYXRhLmlzX21vZCxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRVc2VyQ29tbWVudHModXNlcm5hbWU6IHN0cmluZywgbWF4Q29tbWVudHM6IG51bWJlciA9IDUwMDApOiBQcm9taXNlPFJlZGRpdENvbW1lbnRbXT4ge1xyXG4gICAgY29uc3QgY29tbWVudHM6IFJlZGRpdENvbW1lbnRbXSA9IFtdO1xyXG4gICAgXHJcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIHRoaXMuaXRlcmF0ZUNvbW1lbnRzKHVzZXJuYW1lLCB7IG1heEl0ZW1zOiBtYXhDb21tZW50cyB9KSkge1xyXG4gICAgICBjb21tZW50cy5wdXNoKC4uLmJhdGNoKTtcclxuICAgICAgaWYgKGNvbW1lbnRzLmxlbmd0aCA+PSBtYXhDb21tZW50cykgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBjb21tZW50cy5zbGljZSgwLCBtYXhDb21tZW50cyk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRVc2VyUG9zdHModXNlcm5hbWU6IHN0cmluZywgbWF4UG9zdHM6IG51bWJlciA9IDIwMDApOiBQcm9taXNlPFJlZGRpdFBvc3RbXT4ge1xyXG4gICAgY29uc3QgcG9zdHM6IFJlZGRpdFBvc3RbXSA9IFtdO1xyXG4gICAgXHJcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIHRoaXMuaXRlcmF0ZVBvc3RzKHVzZXJuYW1lLCB7IG1heEl0ZW1zOiBtYXhQb3N0cyB9KSkge1xyXG4gICAgICBwb3N0cy5wdXNoKC4uLmJhdGNoKTtcclxuICAgICAgaWYgKHBvc3RzLmxlbmd0aCA+PSBtYXhQb3N0cykgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBwb3N0cy5zbGljZSgwLCBtYXhQb3N0cyk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRGdWxsVXNlckRhdGEodXNlcm5hbWU6IHN0cmluZywgb3B0aW9uczogRmV0Y2hPcHRpb25zID0ge30pOiBQcm9taXNlPHtcclxuICAgIHVzZXI6IFJlZGRpdFVzZXI7XHJcbiAgICBjb21tZW50czogUmVkZGl0Q29tbWVudFtdO1xyXG4gICAgcG9zdHM6IFJlZGRpdFBvc3RbXTtcclxuICB9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICB0aGlzLmRlYnVnKCdGZXRjaGluZyBjb21wcmVoZW5zaXZlIHVzZXIgZGF0YSBmb3I6JywgdXNlcm5hbWUpO1xyXG4gICAgICBcclxuICAgICAgLy8gRmV0Y2ggdXNlciBpbmZvIGZpcnN0XHJcbiAgICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLmdldFVzZXJJbmZvKHVzZXJuYW1lKTtcclxuICAgICAgXHJcbiAgICAgIC8vIFN0cmVhbSBhbGwgY29udGVudFxyXG4gICAgICBjb25zdCBjb21tZW50czogUmVkZGl0Q29tbWVudFtdID0gW107XHJcbiAgICAgIGNvbnN0IHBvc3RzOiBSZWRkaXRQb3N0W10gPSBbXTtcclxuXHJcbiAgICAgIC8vIENvbGxlY3QgY29tbWVudHNcclxuICAgICAgZm9yIGF3YWl0IChjb25zdCBiYXRjaCBvZiB0aGlzLml0ZXJhdGVDb21tZW50cyh1c2VybmFtZSwgb3B0aW9ucykpIHtcclxuICAgICAgICBjb21tZW50cy5wdXNoKC4uLmJhdGNoKTtcclxuICAgICAgICBpZiAoY29tbWVudHMubGVuZ3RoID49IChvcHRpb25zLm1heEl0ZW1zIHx8IDUwMDApKSBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ29sbGVjdCBwb3N0c1xyXG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIHRoaXMuaXRlcmF0ZVBvc3RzKHVzZXJuYW1lLCBvcHRpb25zKSkge1xyXG4gICAgICAgIHBvc3RzLnB1c2goLi4uYmF0Y2gpO1xyXG4gICAgICAgIGlmIChwb3N0cy5sZW5ndGggPj0gMTAwMCkgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMuZGVidWcoJ0NvbXByZWhlbnNpdmUgZGF0YSBjb21wbGV0ZTonLCB7XHJcbiAgICAgICAgdXNlcm5hbWUsXHJcbiAgICAgICAgY29tbWVudHM6IGNvbW1lbnRzLmxlbmd0aCxcclxuICAgICAgICBwb3N0czogcG9zdHMubGVuZ3RoLFxyXG4gICAgICAgIHRvdGFsQ29udGVudDogY29tbWVudHMubGVuZ3RoICsgcG9zdHMubGVuZ3RoXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgcmV0dXJuIHsgdXNlciwgY29tbWVudHMsIHBvc3RzIH07XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICB0aGlzLmRlYnVnKCdGYWlsZWQgdG8gZmV0Y2ggY29tcHJlaGVuc2l2ZSB1c2VyIGRhdGE6JywgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcicpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldFVzZXJQcmV2aWV3KHVzZXJuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHtcclxuICAgIGV4aXN0czogYm9vbGVhbjtcclxuICAgIGthcm1hOiBudW1iZXI7XHJcbiAgICBhY2NvdW50QWdlOiBzdHJpbmc7XHJcbiAgICByZWNlbnRBY3Rpdml0eTogYm9vbGVhbjtcclxuICAgIGVzdGltYXRlZENvbW1lbnRzOiBudW1iZXI7XHJcbiAgfT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMuZ2V0VXNlckluZm8odXNlcm5hbWUpO1xyXG4gICAgICBcclxuICAgICAgLy8gR2V0IGEgc21hbGwgc2FtcGxlIHRvIGNoZWNrIGZvciByZWNlbnQgYWN0aXZpdHlcclxuICAgICAgY29uc3Qgc2FtcGxlQ29tbWVudHM6IFJlZGRpdENvbW1lbnRbXSA9IFtdO1xyXG4gICAgICBsZXQgYmF0Y2hDb3VudCA9IDA7XHJcbiAgICAgIFxyXG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IGJhdGNoIG9mIHRoaXMuaXRlcmF0ZUNvbW1lbnRzKHVzZXJuYW1lLCB7IG1heEl0ZW1zOiAyMCB9KSkge1xyXG4gICAgICAgIHNhbXBsZUNvbW1lbnRzLnB1c2goLi4uYmF0Y2gpO1xyXG4gICAgICAgIGJhdGNoQ291bnQrKztcclxuICAgICAgICBpZiAoYmF0Y2hDb3VudCA+PSAxKSBicmVhazsgLy8gSnVzdCBmaXJzdCBiYXRjaCBmb3IgcHJldmlld1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBhY2NvdW50QWdlID0gTWF0aC5mbG9vcigoRGF0ZS5ub3coKSAvIDEwMDAgLSB1c2VyLmNyZWF0ZWRfdXRjKSAvICgyNCAqIDYwICogNjApKTtcclxuICAgICAgY29uc3QgYWdlU3RyaW5nID0gYWNjb3VudEFnZSA8IDMwID8gYCR7YWNjb3VudEFnZX0gZGF5c2AgOiBcclxuICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50QWdlIDwgMzY1ID8gYCR7TWF0aC5mbG9vcihhY2NvdW50QWdlIC8gMzApfSBtb250aHNgIDogXHJcbiAgICAgICAgICAgICAgICAgICAgICAgYCR7TWF0aC5mbG9vcihhY2NvdW50QWdlIC8gMzY1KX0geWVhcnNgO1xyXG5cclxuICAgICAgLy8gQmV0dGVyIGVzdGltYXRpb24gYmFzZWQgb24ga2FybWEgYW5kIGFjY291bnQgYWdlXHJcbiAgICAgIGNvbnN0IGRhaWx5S2FybWEgPSB1c2VyLmNvbW1lbnRfa2FybWEgLyBNYXRoLm1heChhY2NvdW50QWdlLCAxKTtcclxuICAgICAgY29uc3QgZXN0aW1hdGVkQ29tbWVudHMgPSBNYXRoLm1pbihNYXRoLm1heChkYWlseUthcm1hICogMiwgMTAwKSwgODAwMCk7XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGV4aXN0czogdHJ1ZSxcclxuICAgICAgICBrYXJtYTogdXNlci50b3RhbF9rYXJtYSxcclxuICAgICAgICBhY2NvdW50QWdlOiBhZ2VTdHJpbmcsXHJcbiAgICAgICAgcmVjZW50QWN0aXZpdHk6IHNhbXBsZUNvbW1lbnRzLmxlbmd0aCA+IDAsXHJcbiAgICAgICAgZXN0aW1hdGVkQ29tbWVudHM6IE1hdGguZmxvb3IoZXN0aW1hdGVkQ29tbWVudHMpXHJcbiAgICAgIH07XHJcbiAgICB9IGNhdGNoIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBleGlzdHM6IGZhbHNlLFxyXG4gICAgICAgIGthcm1hOiAwLFxyXG4gICAgICAgIGFjY291bnRBZ2U6ICdVbmtub3duJyxcclxuICAgICAgICByZWNlbnRBY3Rpdml0eTogZmFsc2UsXHJcbiAgICAgICAgZXN0aW1hdGVkQ29tbWVudHM6IDBcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCByZWRkaXRBcGkgPSBuZXcgUmVkZGl0QXBpU2VydmljZSgpOyJdLCJuYW1lcyI6WyJheGlvcyIsImF4aW9zUmV0cnkiLCJSZWRkaXRBcGlTZXJ2aWNlIiwic2V0VmVyYm9zZSIsInZlcmJvc2UiLCJkZWJ1ZyIsImFyZ3MiLCJjb25zb2xlIiwibG9nIiwibWFrZVJlcXVlc3QiLCJ1cmwiLCJzb3VyY2UiLCJyZXNwb25zZSIsImF4aW9zSW5zdGFuY2UiLCJnZXQiLCJzdGF0dXMiLCJkYXRhIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJpc0F4aW9zRXJyb3IiLCJjb2RlIiwiaW5jbHVkZXMiLCJkZWxheSIsIm1zIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiaXRlcmF0ZUNvbW1lbnRzIiwidXNlcm5hbWUiLCJvcHRpb25zIiwibWF4SXRlbXMiLCJtYXhBZ2UiLCJ0b3RhbEZldGNoZWQiLCJhZnRlciIsImN1dG9mZkRhdGUiLCJEYXRlIiwibm93IiwiYmFzZVVybCIsImNoaWxkcmVuIiwibGVuZ3RoIiwiYmF0Y2giLCJtYXAiLCJjaGlsZCIsImZpbHRlciIsImNvbW1lbnQiLCJib2R5IiwiY3JlYXRlZF91dGMiLCJpZCIsInN1YnJlZGRpdCIsInNjb3JlIiwicGVybWFsaW5rIiwiYXV0aG9yIiwibGlua190aXRsZSIsImJlZm9yZSIsIk1hdGgiLCJmbG9vciIsInB1c2hTaGlmdEF0dGVtcHRzIiwibWF4UHVzaFNoaWZ0QXR0ZW1wdHMiLCJwdXNoU2hpZnRVcmwiLCJsaW5rX2lkIiwibWluIiwiYyIsIml0ZXJhdGVQb3N0cyIsInBvc3QiLCJzZWxmdGV4dCIsInRpdGxlIiwibnVtX2NvbW1lbnRzIiwiZ2V0VXNlckluZm8iLCJuYW1lIiwiY29tbWVudF9rYXJtYSIsImxpbmtfa2FybWEiLCJ0b3RhbF9rYXJtYSIsInZlcmlmaWVkIiwiaXNfZ29sZCIsImlzX21vZCIsImdldFVzZXJDb21tZW50cyIsIm1heENvbW1lbnRzIiwiY29tbWVudHMiLCJwdXNoIiwic2xpY2UiLCJnZXRVc2VyUG9zdHMiLCJtYXhQb3N0cyIsInBvc3RzIiwiZ2V0RnVsbFVzZXJEYXRhIiwidXNlciIsInRvdGFsQ29udGVudCIsImdldFVzZXJQcmV2aWV3Iiwic2FtcGxlQ29tbWVudHMiLCJiYXRjaENvdW50IiwiYWNjb3VudEFnZSIsImFnZVN0cmluZyIsImRhaWx5S2FybWEiLCJtYXgiLCJlc3RpbWF0ZWRDb21tZW50cyIsImV4aXN0cyIsImthcm1hIiwicmVjZW50QWN0aXZpdHkiLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsInRpbWVvdXQiLCJyZXRyaWVzIiwicmV0cnlEZWxheSIsImV4cG9uZW50aWFsRGVsYXkiLCJyZXRyeUNvbmRpdGlvbiIsImlzTmV0d29ya09ySWRlbXBvdGVudFJlcXVlc3RFcnJvciIsIm9uUmV0cnkiLCJyZXRyeUNvdW50IiwicmVxdWVzdENvbmZpZyIsInJlZGRpdEFwaSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/services/redditApi.ts\n"));

/***/ })

});