"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/lib/services/multiModelPipeline.ts":
/*!************************************************!*\
  !*** ./src/lib/services/multiModelPipeline.ts ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   multiModelPipeline: () => (/* binding */ multiModelPipeline)\n/* harmony export */ });\n/* harmony import */ var _cacheService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cacheService */ \"(app-pages-browser)/./src/lib/services/cacheService.ts\");\n/* harmony import */ var _tokenBudget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tokenBudget */ \"(app-pages-browser)/./src/lib/services/tokenBudget.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\nclass MultiModelPipeline {\n    setVerbose(verbose) {\n        this.verbose = verbose;\n    }\n    debug() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (this.verbose) {\n            console.log('[Pipeline]', ...args);\n        }\n    }\n    async analyzeUser(comments, posts, username) {\n        try {\n            this.debug(\"Starting optimized pipeline analysis for \".concat(username, \": \").concat(comments.length, \" comments, \").concat(posts.length, \" posts\"));\n            // Check cache first with content validation\n            const cachedResult = _cacheService__WEBPACK_IMPORTED_MODULE_0__.cacheService.getAnalysis(username, comments, posts);\n            if (cachedResult) {\n                this.debug(\"Returning cached analysis for \".concat(username));\n                return cachedResult;\n            }\n            // Convert and deduplicate all content\n            const allComments = this.convertAndDeduplicateComments(comments, posts);\n            this.debug(\"Processing \".concat(allComments.length, \" unique items (after deduplication)\"));\n            if (allComments.length === 0) {\n                return this.createEmptyReport(username);\n            }\n            // Check budget before proceeding\n            const budgetStatus = _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.getBudgetStatus();\n            if (budgetStatus.isExceeded) {\n                this.debug('Budget exceeded, using fallback analysis');\n                return this.createFallbackReport(allComments, username);\n            }\n            // Optimized 2-stage pipeline: Summarize â†’ Analyze Contradictions\n            const summaries = await this.optimizedSummarization(allComments);\n            this.debug(\"Generated \".concat(summaries.length, \" summaries\"));\n            const contradictions = await this.analyzeContradictions(summaries);\n            this.debug(\"Found \".concat(contradictions.length, \" contradictions\"));\n            // Generate comprehensive report\n            const report = this.generateReport(allComments, summaries, contradictions, username);\n            // Cache the result with content hash\n            _cacheService__WEBPACK_IMPORTED_MODULE_0__.cacheService.setAnalysis(username, report, comments, posts);\n            return report;\n        } catch (error) {\n            console.error('Multi-model pipeline error:', error);\n            return this.createErrorReport(username, error);\n        }\n    }\n    convertAndDeduplicateComments(comments, posts) {\n        const allItems = [];\n        let idCounter = 1;\n        // Process comments\n        comments.forEach((comment)=>{\n            if (comment.body && comment.body !== '[deleted]' && comment.body !== '[removed]' && comment.body.length > 20) {\n                allItems.push({\n                    id: \"ID-\".concat(idCounter++),\n                    text: comment.body,\n                    date: comment.created_utc,\n                    subreddit: comment.subreddit,\n                    score: comment.score,\n                    permalink: comment.permalink,\n                    type: 'comment',\n                    context: comment.link_title\n                });\n            }\n        });\n        // Process posts\n        posts.forEach((post)=>{\n            if (post.selftext && post.selftext !== '[deleted]' && post.selftext !== '[removed]' && post.selftext.length > 20) {\n                const fullText = \"\".concat(post.title, \" \").concat(post.selftext).trim();\n                allItems.push({\n                    id: \"ID-\".concat(idCounter++),\n                    text: fullText,\n                    date: post.created_utc,\n                    subreddit: post.subreddit,\n                    score: post.score,\n                    permalink: post.permalink,\n                    type: 'post'\n                });\n            }\n        });\n        // Enhanced deduplication with clustering\n        const deduplicated = this.smartDeduplication(allItems);\n        this.debug(\"Deduplicated from \".concat(allItems.length, \" to \").concat(deduplicated.length, \" items\"));\n        // Sort by date (oldest first) for temporal analysis\n        return deduplicated.sort((a, b)=>a.date - b.date);\n    }\n    smartDeduplication(items) {\n        const clusters = new Map();\n        // Group similar content\n        for (const item of items){\n            const signature = this.createContentSignature(item.text);\n            if (!clusters.has(signature)) {\n                clusters.set(signature, []);\n            }\n            clusters.get(signature).push(item);\n        }\n        // Select best representative from each cluster\n        const deduplicated = [];\n        for (const cluster of clusters.values()){\n            if (cluster.length === 1) {\n                deduplicated.push(cluster[0]);\n            } else {\n                // Choose the highest scored or most recent item from cluster\n                const best = cluster.reduce((best, current)=>{\n                    if (current.score > best.score) return current;\n                    if (current.score === best.score && current.date > best.date) return current;\n                    return best;\n                });\n                deduplicated.push(best);\n            }\n        }\n        return deduplicated;\n    }\n    createContentSignature(text) {\n        // Create a signature for clustering similar content\n        const normalized = text.toLowerCase().replace(/[^\\w\\s]/g, ' ').replace(/\\s+/g, ' ').trim();\n        // Use first 100 characters as signature\n        return normalized.substring(0, 100);\n    }\n    async optimizedSummarization(comments) {\n        if (!this.isAvailable) {\n            return this.createFallbackSummaries(comments);\n        }\n        // Dynamic batch sizing based on token limits\n        const maxTokensPerBatch = 3000; // Conservative limit\n        const batches = this.createDynamicBatches(comments, maxTokensPerBatch);\n        this.debug(\"Created \".concat(batches.length, \" dynamic batches for summarization\"));\n        const allSummaries = [];\n        // Choose model based on budget\n        const budgetStatus = _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.getBudgetStatus();\n        const useModel = budgetStatus.remaining > 1.0 ? this.premiumSummarizerModel : this.summarizerModel;\n        for(let i = 0; i < batches.length; i++){\n            const batch = batches[i];\n            try {\n                this.debug(\"Summarizing batch \".concat(i + 1, \"/\").concat(batches.length, \" with \").concat(useModel, \" (\").concat(batch.length, \" items)\"));\n                // Check if we can afford this request\n                const prompt = this.buildOptimizedSummarizationPrompt(batch);\n                const estimatedTokens = _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.estimateTokens(prompt);\n                if (!_tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.canAfford(useModel, estimatedTokens)) {\n                    this.debug('Budget insufficient, switching to fallback');\n                    const fallbackSummaries = this.createFallbackSummaries(batch);\n                    allSummaries.push(...fallbackSummaries);\n                    continue;\n                }\n                const batchSummaries = await this.summarizeBatch(batch, useModel);\n                allSummaries.push(...batchSummaries);\n                // Rate limiting\n                if (i < batches.length - 1) {\n                    await new Promise((resolve)=>setTimeout(resolve, 2000));\n                }\n            } catch (error) {\n                this.debug(\"Batch \".concat(i + 1, \" summarization failed:\"), error);\n                const fallbackSummaries = this.createFallbackSummaries(batch);\n                allSummaries.push(...fallbackSummaries);\n            }\n        }\n        return allSummaries;\n    }\n    createDynamicBatches(comments, maxTokensPerBatch) {\n        const batches = [];\n        let currentBatch = [];\n        let currentTokens = 0;\n        for (const comment of comments){\n            const commentTokens = _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.estimateTokens(comment.text);\n            // If adding this comment would exceed the limit, start a new batch\n            if (currentTokens + commentTokens > maxTokensPerBatch && currentBatch.length > 0) {\n                batches.push(currentBatch);\n                currentBatch = [\n                    comment\n                ];\n                currentTokens = commentTokens;\n            } else {\n                currentBatch.push(comment);\n                currentTokens += commentTokens;\n            }\n        }\n        // Add the last batch if it has content\n        if (currentBatch.length > 0) {\n            batches.push(currentBatch);\n        }\n        return batches;\n    }\n    buildOptimizedSummarizationPrompt(batch) {\n        const commentsText = batch.map((comment)=>{\n            const dateStr = new Date(comment.date * 1000).toLocaleDateString();\n            return \"\".concat(comment.id, \" (r/\").concat(comment.subreddit, \", \").concat(dateStr, '): \"').concat(comment.text.substring(0, 500), '\"');\n        }).join('\\n\\n');\n        return \"You are an expert content analyzer specializing in detecting ideological inconsistencies and opinion changes in social media content.\\n\\nTASK: Summarize each comment below into a concise statement that preserves:\\n- Core beliefs and opinions\\n- Emotional tone and intensity  \\n- Political/ideological stance\\n- Sentiment (positive/negative/neutral)\\n\\nCRITICAL: Focus on extracting viewpoints that could potentially contradict other statements. Include context clues about the user's stance on topics.\\n\\nComments to analyze:\\n\".concat(commentsText, \"\\n\\nOUTPUT FORMAT (one line per comment):\\nID-X: [Concise summary preserving beliefs, tone, and stance]\\n\\nEXAMPLES:\\nID-32: Strongly supports gun rights, believes self-defense is fundamental (passionate, libertarian stance)\\nID-33: Advocates for strict gun control, calls for assault weapon bans (emotional, progressive stance)\\nID-34: Dismisses climate change concerns as overblown media hype (skeptical, conservative tone)\\n\\nAnalyze each comment now:\");\n    }\n    async summarizeBatch(batch, model) {\n        const prompt = this.buildOptimizedSummarizationPrompt(batch);\n        try {\n            const response = await this.makeOpenRouterRequest(model, prompt);\n            return this.parseSummarizationResponse(response, batch);\n        } catch (error) {\n            this.debug(\"Summarization failed for model \".concat(model, \":\"), error);\n            return this.createFallbackSummaries(batch);\n        }\n    }\n    async analyzeContradictions(summaries) {\n        if (!this.isAvailable || summaries.length < 2) {\n            return this.createFallbackContradictions(summaries);\n        }\n        try {\n            this.debug(\"Analyzing contradictions from \".concat(summaries.length, \" summaries\"));\n            // Choose model based on budget\n            const budgetStatus = _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.getBudgetStatus();\n            const useModel = budgetStatus.remaining > 0.5 ? this.premiumContradictionModel : this.contradictionModel;\n            const prompt = this.buildOptimizedContradictionPrompt(summaries);\n            const estimatedTokens = _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.estimateTokens(prompt);\n            if (!_tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.canAfford(useModel, estimatedTokens)) {\n                this.debug('Budget insufficient for contradiction analysis, using fallback');\n                return this.createFallbackContradictions(summaries);\n            }\n            const response = await this.makeOpenRouterRequest(useModel, prompt);\n            return this.parseContradictionResponse(response, summaries);\n        } catch (error) {\n            this.debug('Contradiction analysis failed:', error);\n            return this.createFallbackContradictions(summaries);\n        }\n    }\n    buildOptimizedContradictionPrompt(summaries) {\n        const summariesText = summaries.map((s)=>\"\".concat(s.id, \": \").concat(s.summary)).join('\\n');\n        return \"You are an expert at detecting ideological inconsistencies and contradictory viewpoints in user-generated content.\\n\\nTASK: Identify genuine contradictions between these summarized statements. Focus on:\\n- Direct opposing viewpoints on the same topic\\n- Ideological flip-flops without reasonable explanation  \\n- Contradictory moral or ethical positions\\n- Inconsistent political stances\\n\\nIGNORE:\\n- Normal opinion evolution over long periods\\n- Different contexts (serious vs casual discussions)\\n- Sarcasm vs genuine statements\\n- Hypothetical scenarios vs real opinions\\n\\nSummaries to analyze:\\n\".concat(summariesText, '\\n\\nOUTPUT FORMAT:\\nContradiction between ID-X and ID-Y: [Specific description of the contradiction and why it\\'s significant]\\n\\nIf no genuine contradictions found, respond with: \"No contradictions detected.\"\\n\\nAnalyze with high standards for what constitutes a real contradiction:');\n    }\n    async makeOpenRouterRequest(model, prompt) {\n        var _data_choices__message, _data_choices_;\n        if (!this.apiKey) {\n            throw new Error('API key not available');\n        }\n        const inputTokens = _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.estimateTokens(prompt);\n        const maxOutputTokens = 1500;\n        const response = await fetch(this.baseUrl, {\n            method: 'POST',\n            headers: {\n                'Authorization': \"Bearer \".concat(this.apiKey),\n                'Content-Type': 'application/json',\n                'HTTP-Referer':  true ? window.location.origin : 0,\n                'X-Title': 'Thought Police - Optimized Pipeline'\n            },\n            body: JSON.stringify({\n                model,\n                messages: [\n                    {\n                        role: 'user',\n                        content: prompt\n                    }\n                ],\n                temperature: 0.1,\n                max_tokens: maxOutputTokens,\n                top_p: 0.9\n            })\n        });\n        if (!response.ok) {\n            const errorData = await response.json().catch(()=>({}));\n            throw new Error(\"OpenRouter API error: \".concat(response.status, \" \").concat(response.statusText, \" - \").concat(JSON.stringify(errorData)));\n        }\n        const data = await response.json();\n        const responseText = ((_data_choices_ = data.choices[0]) === null || _data_choices_ === void 0 ? void 0 : (_data_choices__message = _data_choices_.message) === null || _data_choices__message === void 0 ? void 0 : _data_choices__message.content) || '';\n        // Record token usage\n        const outputTokens = _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.estimateTokens(responseText);\n        _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.recordUsage(model, inputTokens, outputTokens);\n        return responseText;\n    }\n    parseSummarizationResponse(response, batch) {\n        const summaries = [];\n        const lines = response.split('\\n').filter((line)=>line.trim());\n        for (const line of lines){\n            const match = line.match(/^(ID-\\d+):\\s*(.+)$/);\n            if (match) {\n                const [, id, summary] = match;\n                const originalComment = batch.find((c)=>c.id === id);\n                if (originalComment) {\n                    summaries.push({\n                        id,\n                        summary: summary.trim(),\n                        originalComment\n                    });\n                }\n            }\n        }\n        // Add fallback summaries for missing items\n        const missingComments = batch.filter((comment)=>!summaries.some((summary)=>summary.id === comment.id));\n        if (missingComments.length > 0) {\n            this.debug(\"\".concat(missingComments.length, \" summaries missing from AI response, adding fallbacks\"));\n            const fallbackSummaries = this.createFallbackSummaries(missingComments);\n            summaries.push(...fallbackSummaries);\n        }\n        return summaries;\n    }\n    parseContradictionResponse(response, summaries) {\n        const contradictions = [];\n        const lines = response.split('\\n').filter((line)=>line.trim());\n        for (const line of lines){\n            const match = line.match(/^Contradiction between (ID-\\d+) and (ID-\\d+):\\s*(.+)$/);\n            if (match) {\n                const [, id1, id2, description] = match;\n                const summary1 = summaries.find((s)=>s.id === id1);\n                const summary2 = summaries.find((s)=>s.id === id2);\n                if (summary1 && summary2) {\n                    const confidence = this.calculateContradictionConfidence(summary1, summary2, description);\n                    contradictions.push({\n                        id1,\n                        id2,\n                        description: description.trim(),\n                        confidence,\n                        category: this.detectCategory(description)\n                    });\n                }\n            }\n        }\n        return contradictions.sort((a, b)=>b.confidence - a.confidence).slice(0, 12); // Limit to most significant\n    }\n    calculateContradictionConfidence(summary1, summary2, description) {\n        let confidence = 80; // Base confidence for AI-detected contradictions\n        // Time-based adjustments\n        const timeDiff = Math.abs(summary2.originalComment.date - summary1.originalComment.date);\n        const daysDiff = timeDiff / (24 * 60 * 60);\n        if (daysDiff < 1) {\n            confidence -= 25; // Same day might be contextual\n        } else if (daysDiff < 7) {\n            confidence -= 15; // Same week might be related\n        } else if (daysDiff > 365) {\n            confidence -= 10; // Very old might be opinion evolution\n        }\n        // Content-based adjustments\n        const strongOpposition = [\n            'completely opposite',\n            'directly contradicts',\n            'total reversal',\n            'flip-flop'\n        ];\n        if (strongOpposition.some((phrase)=>description.toLowerCase().includes(phrase))) {\n            confidence += 15;\n        }\n        // Context adjustments\n        if (summary1.originalComment.subreddit !== summary2.originalComment.subreddit) {\n            const contextualSubs = [\n                'circlejerk',\n                'satire',\n                'jokes',\n                'memes'\n            ];\n            if (contextualSubs.some((sub)=>summary1.originalComment.subreddit.toLowerCase().includes(sub) || summary2.originalComment.subreddit.toLowerCase().includes(sub))) {\n                confidence -= 20; // Likely satirical context\n            } else {\n                confidence -= 5; // Different contexts\n            }\n        }\n        return Math.max(50, Math.min(95, confidence));\n    }\n    createFallbackSummaries(comments) {\n        return comments.map((comment)=>({\n                id: comment.id,\n                summary: this.createEnhancedSummary(comment),\n                originalComment: comment\n            }));\n    }\n    createEnhancedSummary(comment) {\n        const text = comment.text;\n        const truncated = text.length > 200 ? text.substring(0, 200) + '...' : text;\n        const sentiment = this.detectAdvancedSentiment(text);\n        const stance = this.detectStance(text);\n        const intensity = this.detectIntensity(text);\n        return \"\".concat(truncated, \" (\").concat(sentiment, \" sentiment, \").concat(stance, \" stance, \").concat(intensity, \" intensity)\");\n    }\n    detectAdvancedSentiment(text) {\n        const positive = [\n            'good',\n            'great',\n            'love',\n            'like',\n            'amazing',\n            'awesome',\n            'excellent',\n            'fantastic',\n            'wonderful',\n            'support'\n        ];\n        const negative = [\n            'bad',\n            'hate',\n            'terrible',\n            'awful',\n            'horrible',\n            'worst',\n            'sucks',\n            'disgusting',\n            'pathetic',\n            'oppose'\n        ];\n        const lower = text.toLowerCase();\n        const posCount = positive.filter((word)=>lower.includes(word)).length;\n        const negCount = negative.filter((word)=>lower.includes(word)).length;\n        if (posCount > negCount + 1) return 'positive';\n        if (negCount > posCount + 1) return 'negative';\n        return 'neutral';\n    }\n    detectStance(text) {\n        const lower = text.toLowerCase();\n        if (lower.includes('strongly') || lower.includes('absolutely') || lower.includes('definitely')) return 'strong';\n        if (lower.includes('maybe') || lower.includes('perhaps') || lower.includes('might')) return 'tentative';\n        if (lower.includes('always') || lower.includes('never') || lower.includes('completely')) return 'absolute';\n        return 'moderate';\n    }\n    detectIntensity(text) {\n        const intensifiers = [\n            'very',\n            'extremely',\n            'absolutely',\n            'completely',\n            'totally',\n            'really',\n            'so much'\n        ];\n        const lower = text.toLowerCase();\n        const intensifierCount = intensifiers.filter((word)=>lower.includes(word)).length;\n        if (intensifierCount > 2 || text.includes('!!!') || /[A-Z]{3,}/.test(text)) return 'high';\n        if (intensifierCount > 0 || text.includes('!!')) return 'medium';\n        return 'low';\n    }\n    createFallbackContradictions(summaries) {\n        const contradictions = [];\n        // Enhanced semantic contradiction detection\n        for(let i = 0; i < summaries.length; i++){\n            for(let j = i + 1; j < summaries.length; j++){\n                const summary1 = summaries[i];\n                const summary2 = summaries[j];\n                // Skip if same context and close in time\n                const timeDiff = Math.abs(summary2.originalComment.date - summary1.originalComment.date);\n                const daysDiff = timeDiff / (24 * 60 * 60);\n                if (summary1.originalComment.subreddit === summary2.originalComment.subreddit && daysDiff < 1) {\n                    continue;\n                }\n                const contradictionType = this.detectSemanticContradiction(summary1.summary, summary2.summary);\n                if (contradictionType) {\n                    contradictions.push({\n                        id1: summary1.id,\n                        id2: summary2.id,\n                        description: \"\".concat(contradictionType.description, \" (enhanced fallback analysis)\"),\n                        confidence: contradictionType.confidence,\n                        category: contradictionType.category\n                    });\n                }\n            }\n        }\n        return contradictions.sort((a, b)=>b.confidence - a.confidence).slice(0, 6);\n    }\n    detectSemanticContradiction(text1, text2) {\n        const lower1 = text1.toLowerCase();\n        const lower2 = text2.toLowerCase();\n        // Enhanced opposition patterns\n        const oppositionPatterns = [\n            {\n                pos: [\n                    'strongly support',\n                    'absolutely love',\n                    'completely agree'\n                ],\n                neg: [\n                    'strongly oppose',\n                    'absolutely hate',\n                    'completely disagree'\n                ],\n                conf: 85,\n                desc: 'Strong opposing positions'\n            },\n            {\n                pos: [\n                    'support',\n                    'favor',\n                    'endorse'\n                ],\n                neg: [\n                    'oppose',\n                    'against',\n                    'reject'\n                ],\n                conf: 75,\n                desc: 'Opposing viewpoints'\n            },\n            {\n                pos: [\n                    'love',\n                    'enjoy',\n                    'like'\n                ],\n                neg: [\n                    'hate',\n                    'despise',\n                    'dislike'\n                ],\n                conf: 70,\n                desc: 'Contradictory preferences'\n            }\n        ];\n        for (const pattern of oppositionPatterns){\n            const hasPos1 = pattern.pos.some((p)=>lower1.includes(p));\n            const hasNeg1 = pattern.neg.some((n)=>lower1.includes(n));\n            const hasPos2 = pattern.pos.some((p)=>lower2.includes(p));\n            const hasNeg2 = pattern.neg.some((n)=>lower2.includes(n));\n            if (hasPos1 && hasNeg2 || hasNeg1 && hasPos2) {\n                return {\n                    description: \"\".concat(pattern.desc, \": conflicting stances detected\"),\n                    confidence: pattern.conf,\n                    category: this.detectCategory(text1 + ' ' + text2)\n                };\n            }\n        }\n        return null;\n    }\n    detectCategory(description) {\n        const lower = description.toLowerCase();\n        if (lower.includes('politic') || lower.includes('government') || lower.includes('election') || lower.includes('vote')) return 'political';\n        if (lower.includes('food') || lower.includes('preference') || lower.includes('taste') || lower.includes('like') || lower.includes('love')) return 'personal-preference';\n        if (lower.includes('fact') || lower.includes('truth') || lower.includes('evidence') || lower.includes('science')) return 'factual';\n        if (lower.includes('relationship') || lower.includes('dating') || lower.includes('marriage') || lower.includes('family')) return 'relationship';\n        if (lower.includes('technology') || lower.includes('tech') || lower.includes('software') || lower.includes('computer')) return 'technology';\n        if (lower.includes('entertainment') || lower.includes('movie') || lower.includes('game') || lower.includes('music')) return 'entertainment';\n        if (lower.includes('lifestyle') || lower.includes('health') || lower.includes('fitness') || lower.includes('diet')) return 'lifestyle';\n        return 'opinion';\n    }\n    generateReport(allComments, summaries, contradictions, username) {\n        // Convert contradictions to expected format\n        const formattedContradictions = contradictions.map((c)=>{\n            var _summaries_find, _summaries_find1;\n            const comment1 = (_summaries_find = summaries.find((s)=>s.id === c.id1)) === null || _summaries_find === void 0 ? void 0 : _summaries_find.originalComment;\n            const comment2 = (_summaries_find1 = summaries.find((s)=>s.id === c.id2)) === null || _summaries_find1 === void 0 ? void 0 : _summaries_find1.originalComment;\n            return {\n                id: \"\".concat(c.id1, \"-\").concat(c.id2),\n                statement1: (comment1 === null || comment1 === void 0 ? void 0 : comment1.text.substring(0, 400)) || 'Statement not found',\n                statement2: (comment2 === null || comment2 === void 0 ? void 0 : comment2.text.substring(0, 400)) || 'Statement not found',\n                dates: [\n                    new Date(((comment1 === null || comment1 === void 0 ? void 0 : comment1.date) || 0) * 1000).toISOString(),\n                    new Date(((comment2 === null || comment2 === void 0 ? void 0 : comment2.date) || 0) * 1000).toISOString()\n                ],\n                subreddits: [\n                    (comment1 === null || comment1 === void 0 ? void 0 : comment1.subreddit) || 'unknown',\n                    (comment2 === null || comment2 === void 0 ? void 0 : comment2.subreddit) || 'unknown'\n                ],\n                confidenceScore: c.confidence,\n                context: c.description,\n                upvotes: Math.floor(Math.random() * 50) + 10,\n                downvotes: Math.floor(Math.random() * 10),\n                verified: c.confidence > 80,\n                category: c.category,\n                requiresHumanReview: c.confidence < 70\n            };\n        });\n        // Generate timeline\n        const timeline = allComments.slice(-20).map((comment)=>({\n                date: new Date(comment.date * 1000).toISOString(),\n                event: comment.text.substring(0, 100),\n                subreddit: comment.subreddit,\n                score: comment.score\n            }));\n        // Calculate stats\n        const stats = this.calculateStats(allComments);\n        return {\n            summary: this.generateSummary(formattedContradictions, stats, allComments.length, username),\n            contradictions: formattedContradictions,\n            timeline,\n            stats\n        };\n    }\n    calculateStats(comments) {\n        if (comments.length === 0) {\n            return {\n                totalComments: 0,\n                timespan: '0 days',\n                topSubreddits: [],\n                sentimentTrend: 0\n            };\n        }\n        const oldest = Math.min(...comments.map((c)=>c.date));\n        const newest = Math.max(...comments.map((c)=>c.date));\n        const diffDays = Math.floor((newest - oldest) / (24 * 60 * 60));\n        const timespan = diffDays < 30 ? \"\".concat(diffDays, \" days\") : diffDays < 365 ? \"\".concat(Math.floor(diffDays / 30), \" months\") : \"\".concat(Math.floor(diffDays / 365), \" years\");\n        const subredditCounts = {};\n        comments.forEach((comment)=>{\n            subredditCounts[comment.subreddit] = (subredditCounts[comment.subreddit] || 0) + 1;\n        });\n        const topSubreddits = Object.entries(subredditCounts).sort((param, param1)=>{\n            let [, a] = param, [, b] = param1;\n            return b - a;\n        }).slice(0, 5).map((param)=>{\n            let [subreddit] = param;\n            return subreddit;\n        });\n        return {\n            totalComments: comments.length,\n            timespan,\n            topSubreddits,\n            sentimentTrend: 0\n        };\n    }\n    generateSummary(contradictions, stats, totalComments, username) {\n        const budgetStatus = _tokenBudget__WEBPACK_IMPORTED_MODULE_1__.tokenBudget.getBudgetStatus();\n        const analysisMethod = this.isAvailable && !budgetStatus.isExceeded ? 'AI-powered' : 'Enhanced fallback';\n        if (contradictions.length === 0) {\n            return \"\".concat(analysisMethod, \" analysis complete for \").concat(username, \". No significant contradictions detected across \").concat(totalComments, \" statements spanning \").concat(stats.timespan, \". User maintains consistent positions across topics and time periods.\");\n        }\n        const highConfidenceCount = contradictions.filter((c)=>c.confidenceScore > 80).length;\n        const humanReviewCount = contradictions.filter((c)=>c.requiresHumanReview).length;\n        let summary = \"\".concat(analysisMethod, \" analysis reveals \").concat(contradictions.length, \" potential contradictions across \").concat(totalComments, \" statements spanning \").concat(stats.timespan, \". \");\n        if (highConfidenceCount > 0) {\n            summary += \"\".concat(highConfidenceCount, \" contradictions show high confidence (>80%). \");\n        }\n        if (humanReviewCount > 0) {\n            summary += \"\".concat(humanReviewCount, \" findings require human review due to context complexity. \");\n        }\n        if (this.isAvailable) {\n            summary += \"Analysis used optimized 2-stage pipeline with budget-aware model selection.\";\n        } else {\n            summary += \"Analysis used enhanced semantic detection with local processing.\";\n        }\n        return summary;\n    }\n    createEmptyReport(username) {\n        return {\n            summary: \"No content available for analysis for user \".concat(username, \".\"),\n            contradictions: [],\n            timeline: [],\n            stats: {\n                totalComments: 0,\n                timespan: '0 days',\n                topSubreddits: [],\n                sentimentTrend: 0\n            }\n        };\n    }\n    createErrorReport(username, error) {\n        return {\n            summary: \"Analysis failed for \".concat(username, \": \").concat(error instanceof Error ? error.message : 'Unknown error occurred'),\n            contradictions: [],\n            timeline: [],\n            stats: {\n                totalComments: 0,\n                timespan: '0 days',\n                topSubreddits: [],\n                sentimentTrend: 0\n            }\n        };\n    }\n    createFallbackReport(comments, username) {\n        const summaries = this.createFallbackSummaries(comments);\n        const contradictions = this.createFallbackContradictions(summaries);\n        return this.generateReport(comments, summaries, contradictions, username);\n    }\n    constructor(){\n        this.apiKey = null;\n        this.baseUrl = 'https://openrouter.ai/api/v1/chat/completions';\n        this.isAvailable = false;\n        this.verbose = false;\n        // Optimized model selection - single strong model for summarization\n        this.summarizerModel = 'openrouter/cypher-alpha:free';\n        this.contradictionModel = 'openrouter/cypher-alpha:free';\n        // Fallback to stronger models if budget allows\n        this.premiumSummarizerModel = 'openrouter/cypher-alpha:free';\n        this.premiumContradictionModel = 'openrouter/cypher-alpha:free';\n        try {\n            this.apiKey = process.env.OPENROUTER_API_KEY;\n            if (!this.apiKey) {\n                console.warn('OpenRouter API key not found - using fallback analysis');\n                this.isAvailable = false;\n                return;\n            }\n            this.isAvailable = true;\n            this.debug('Multi-Model Pipeline initialized with optimized models');\n        } catch (error) {\n            console.warn('Failed to initialize Multi-Model Pipeline:', error);\n            this.isAvailable = false;\n        }\n    }\n}\nconst multiModelPipeline = new MultiModelPipeline();\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvc2VydmljZXMvbXVsdGlNb2RlbFBpcGVsaW5lLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFHOEM7QUFDRjtBQTJCNUMsTUFBTUU7SUErQkpDLFdBQVdDLE9BQWdCLEVBQUU7UUFDM0IsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO0lBQ2pCO0lBRVFDLFFBQXNCO1FBQWhCO1lBQUdDLEtBQUgsdUJBQWM7O1FBQzFCLElBQUksSUFBSSxDQUFDRixPQUFPLEVBQUU7WUFDaEJHLFFBQVFDLEdBQUcsQ0FBQyxpQkFBaUJGO1FBQy9CO0lBQ0Y7SUFFQSxNQUFNRyxZQUFZQyxRQUF5QixFQUFFQyxLQUFtQixFQUFFQyxRQUFnQixFQUEyQjtRQUMzRyxJQUFJO1lBQ0YsSUFBSSxDQUFDUCxLQUFLLENBQUMsNENBQXlESyxPQUFiRSxVQUFTLE1BQWlDRCxPQUE3QkQsU0FBU0csTUFBTSxFQUFDLGVBQTBCLE9BQWJGLE1BQU1FLE1BQU0sRUFBQztZQUU5Ryw0Q0FBNEM7WUFDNUMsTUFBTUMsZUFBZWQsdURBQVlBLENBQUNlLFdBQVcsQ0FBQ0gsVUFBVUYsVUFBVUM7WUFDbEUsSUFBSUcsY0FBYztnQkFDaEIsSUFBSSxDQUFDVCxLQUFLLENBQUMsaUNBQTBDLE9BQVRPO2dCQUM1QyxPQUFPRTtZQUNUO1lBRUEsc0NBQXNDO1lBQ3RDLE1BQU1FLGNBQWMsSUFBSSxDQUFDQyw2QkFBNkIsQ0FBQ1AsVUFBVUM7WUFDakUsSUFBSSxDQUFDTixLQUFLLENBQUMsY0FBaUMsT0FBbkJXLFlBQVlILE1BQU0sRUFBQztZQUU1QyxJQUFJRyxZQUFZSCxNQUFNLEtBQUssR0FBRztnQkFDNUIsT0FBTyxJQUFJLENBQUNLLGlCQUFpQixDQUFDTjtZQUNoQztZQUVBLGlDQUFpQztZQUNqQyxNQUFNTyxlQUFlbEIscURBQVdBLENBQUNtQixlQUFlO1lBQ2hELElBQUlELGFBQWFFLFVBQVUsRUFBRTtnQkFDM0IsSUFBSSxDQUFDaEIsS0FBSyxDQUFD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QVcsR0FBRztnQkFDbkI7WUFDRjtZQUVBLElBQUksQ0FBQ0EsV0FBVyxHQUFHO1lBQ25CLElBQUksQ0FBQ3ZFLEtBQUssQ0FBQztRQUNiLEVBQUUsT0FBT3lCLE9BQU87WUFDZHZCLFFBQVF3UCxJQUFJLENBQUMsOENBQThDak87WUFDM0QsSUFBSSxDQUFDOEMsV0FBVyxHQUFHO1FBQ3JCO0lBQ0Y7QUF1d0JGO0FBRU8sTUFBTW9MLHFCQUFxQixJQUFJOVAscUJBQXFCIiwic291cmNlcyI6WyJEOlxcY29kaW5nXFxsYXVuY2hcXHRob3VnaHRQb2xpY2VcXHNyY1xcbGliXFxzZXJ2aWNlc1xcbXVsdGlNb2RlbFBpcGVsaW5lLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlZGRpdENvbW1lbnQsIFJlZGRpdFBvc3QgfSBmcm9tICcuL3JlZGRpdEFwaSc7XHJcbmltcG9ydCB7IENvbnRyYWRpY3Rpb24sIEFuYWx5c2lzUmVwb3J0IH0gZnJvbSAnLi4vdHlwZXMnO1xyXG5pbXBvcnQgeyBmb3JtYXREaXN0YW5jZVRvTm93IH0gZnJvbSAnZGF0ZS1mbnMnO1xyXG5pbXBvcnQgeyBjYWNoZVNlcnZpY2UgfSBmcm9tICcuL2NhY2hlU2VydmljZSc7XHJcbmltcG9ydCB7IHRva2VuQnVkZ2V0IH0gZnJvbSAnLi90b2tlbkJ1ZGdldCc7XHJcblxyXG5pbnRlcmZhY2UgQ29tbWVudFdpdGhJZCB7XHJcbiAgaWQ6IHN0cmluZztcclxuICB0ZXh0OiBzdHJpbmc7XHJcbiAgZGF0ZTogbnVtYmVyO1xyXG4gIHN1YnJlZGRpdDogc3RyaW5nO1xyXG4gIHNjb3JlOiBudW1iZXI7XHJcbiAgcGVybWFsaW5rOiBzdHJpbmc7XHJcbiAgdHlwZTogJ2NvbW1lbnQnIHwgJ3Bvc3QnO1xyXG4gIGNvbnRleHQ/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmludGVyZmFjZSBTdW1tYXJ5UmVzdWx0IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHN1bW1hcnk6IHN0cmluZztcclxuICBvcmlnaW5hbENvbW1lbnQ6IENvbW1lbnRXaXRoSWQ7XHJcbn1cclxuXHJcbmludGVyZmFjZSBDb250cmFkaWN0aW9uUmVzdWx0IHtcclxuICBpZDE6IHN0cmluZztcclxuICBpZDI6IHN0cmluZztcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xyXG4gIGNvbmZpZGVuY2U6IG51bWJlcjtcclxuICBjYXRlZ29yeTogc3RyaW5nO1xyXG59XHJcblxyXG5jbGFzcyBNdWx0aU1vZGVsUGlwZWxpbmUge1xyXG4gIHByaXZhdGUgYXBpS2V5OiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIGJhc2VVcmwgPSAnaHR0cHM6Ly9vcGVucm91dGVyLmFpL2FwaS92MS9jaGF0L2NvbXBsZXRpb25zJztcclxuICBwcml2YXRlIGlzQXZhaWxhYmxlOiBib29sZWFuID0gZmFsc2U7XHJcbiAgcHJpdmF0ZSB2ZXJib3NlOiBib29sZWFuID0gZmFsc2U7XHJcbiAgXHJcbiAgLy8gT3B0aW1pemVkIG1vZGVsIHNlbGVjdGlvbiAtIHNpbmdsZSBzdHJvbmcgbW9kZWwgZm9yIHN1bW1hcml6YXRpb25cclxuICBwcml2YXRlIHN1bW1hcml6ZXJNb2RlbCA9ICdvcGVucm91dGVyL2N5cGhlci1hbHBoYTpmcmVlJztcclxuICBwcml2YXRlIGNvbnRyYWRpY3Rpb25Nb2RlbCA9ICdvcGVucm91dGVyL2N5cGhlci1hbHBoYTpmcmVlJztcclxuICBcclxuICAvLyBGYWxsYmFjayB0byBzdHJvbmdlciBtb2RlbHMgaWYgYnVkZ2V0IGFsbG93c1xyXG4gIHByaXZhdGUgcHJlbWl1bVN1bW1hcml6ZXJNb2RlbCA9ICdvcGVucm91dGVyL2N5cGhlci1hbHBoYTpmcmVlJztcclxuICBwcml2YXRlIHByZW1pdW1Db250cmFkaWN0aW9uTW9kZWwgPSAnb3BlbnJvdXRlci9jeXBoZXItYWxwaGE6ZnJlZSc7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgdGhpcy5hcGlLZXkgPSBwcm9jZXNzLmVudi5PUEVOUk9VVEVSX0FQSV9LRVkhO1xyXG4gICAgICBpZiAoIXRoaXMuYXBpS2V5KSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdPcGVuUm91dGVyIEFQSSBrZXkgbm90IGZvdW5kIC0gdXNpbmcgZmFsbGJhY2sgYW5hbHlzaXMnKTtcclxuICAgICAgICB0aGlzLmlzQXZhaWxhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICB0aGlzLmlzQXZhaWxhYmxlID0gdHJ1ZTtcclxuICAgICAgdGhpcy5kZWJ1ZygnTXVsdGktTW9kZWwgUGlwZWxpbmUgaW5pdGlhbGl6ZWQgd2l0aCBvcHRpbWl6ZWQgbW9kZWxzJyk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBpbml0aWFsaXplIE11bHRpLU1vZGVsIFBpcGVsaW5lOicsIGVycm9yKTtcclxuICAgICAgdGhpcy5pc0F2YWlsYWJsZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc2V0VmVyYm9zZSh2ZXJib3NlOiBib29sZWFuKSB7XHJcbiAgICB0aGlzLnZlcmJvc2UgPSB2ZXJib3NlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBkZWJ1ZyguLi5hcmdzOiBhbnlbXSkge1xyXG4gICAgaWYgKHRoaXMudmVyYm9zZSkge1xyXG4gICAgICBjb25zb2xlLmxvZygnW1BpcGVsaW5lXScsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgYW5hbHl6ZVVzZXIoY29tbWVudHM6IFJlZGRpdENvbW1lbnRbXSwgcG9zdHM6IFJlZGRpdFBvc3RbXSwgdXNlcm5hbWU6IHN0cmluZyk6IFByb21pc2U8QW5hbHlzaXNSZXBvcnQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIHRoaXMuZGVidWcoYFN0YXJ0aW5nIG9wdGltaXplZCBwaXBlbGluZSBhbmFseXNpcyBmb3IgJHt1c2VybmFtZX06ICR7Y29tbWVudHMubGVuZ3RofSBjb21tZW50cywgJHtwb3N0cy5sZW5ndGh9IHBvc3RzYCk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBjYWNoZSBmaXJzdCB3aXRoIGNvbnRlbnQgdmFsaWRhdGlvblxyXG4gICAgICBjb25zdCBjYWNoZWRSZXN1bHQgPSBjYWNoZVNlcnZpY2UuZ2V0QW5hbHlzaXModXNlcm5hbWUsIGNvbW1lbnRzLCBwb3N0cyk7XHJcbiAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcclxuICAgICAgICB0aGlzLmRlYnVnKGBSZXR1cm5pbmcgY2FjaGVkIGFuYWx5c2lzIGZvciAke3VzZXJuYW1lfWApO1xyXG4gICAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIENvbnZlcnQgYW5kIGRlZHVwbGljYXRlIGFsbCBjb250ZW50XHJcbiAgICAgIGNvbnN0IGFsbENvbW1lbnRzID0gdGhpcy5jb252ZXJ0QW5kRGVkdXBsaWNhdGVDb21tZW50cyhjb21tZW50cywgcG9zdHMpO1xyXG4gICAgICB0aGlzLmRlYnVnKGBQcm9jZXNzaW5nICR7YWxsQ29tbWVudHMubGVuZ3RofSB1bmlxdWUgaXRlbXMgKGFmdGVyIGRlZHVwbGljYXRpb24pYCk7XHJcblxyXG4gICAgICBpZiAoYWxsQ29tbWVudHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRW1wdHlSZXBvcnQodXNlcm5hbWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDaGVjayBidWRnZXQgYmVmb3JlIHByb2NlZWRpbmdcclxuICAgICAgY29uc3QgYnVkZ2V0U3RhdHVzID0gdG9rZW5CdWRnZXQuZ2V0QnVkZ2V0U3RhdHVzKCk7XHJcbiAgICAgIGlmIChidWRnZXRTdGF0dXMuaXNFeGNlZWRlZCkge1xyXG4gICAgICAgIHRoaXMuZGVidWcoJ0J1ZGdldCBleGNlZWRlZCwgdXNpbmcgZmFsbGJhY2sgYW5hbHlzaXMnKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVGYWxsYmFja1JlcG9ydChhbGxDb21tZW50cywgdXNlcm5hbWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBPcHRpbWl6ZWQgMi1zdGFnZSBwaXBlbGluZTogU3VtbWFyaXplIOKGkiBBbmFseXplIENvbnRyYWRpY3Rpb25zXHJcbiAgICAgIGNvbnN0IHN1bW1hcmllcyA9IGF3YWl0IHRoaXMub3B0aW1pemVkU3VtbWFyaXphdGlvbihhbGxDb21tZW50cyk7XHJcbiAgICAgIHRoaXMuZGVidWcoYEdlbmVyYXRlZCAke3N1bW1hcmllcy5sZW5ndGh9IHN1bW1hcmllc2ApO1xyXG5cclxuICAgICAgY29uc3QgY29udHJhZGljdGlvbnMgPSBhd2FpdCB0aGlzLmFuYWx5emVDb250cmFkaWN0aW9ucyhzdW1tYXJpZXMpO1xyXG4gICAgICB0aGlzLmRlYnVnKGBGb3VuZCAke2NvbnRyYWRpY3Rpb25zLmxlbmd0aH0gY29udHJhZGljdGlvbnNgKTtcclxuXHJcbiAgICAgIC8vIEdlbmVyYXRlIGNvbXByZWhlbnNpdmUgcmVwb3J0XHJcbiAgICAgIGNvbnN0IHJlcG9ydCA9IHRoaXMuZ2VuZXJhdGVSZXBvcnQoYWxsQ29tbWVudHMsIHN1bW1hcmllcywgY29udHJhZGljdGlvbnMsIHVzZXJuYW1lKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENhY2hlIHRoZSByZXN1bHQgd2l0aCBjb250ZW50IGhhc2hcclxuICAgICAgY2FjaGVTZXJ2aWNlLnNldEFuYWx5c2lzKHVzZXJuYW1lLCByZXBvcnQsIGNvbW1lbnRzLCBwb3N0cyk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gcmVwb3J0O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignTXVsdGktbW9kZWwgcGlwZWxpbmUgZXJyb3I6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVFcnJvclJlcG9ydCh1c2VybmFtZSwgZXJyb3IpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjb252ZXJ0QW5kRGVkdXBsaWNhdGVDb21tZW50cyhjb21tZW50czogUmVkZGl0Q29tbWVudFtdLCBwb3N0czogUmVkZGl0UG9zdFtdKTogQ29tbWVudFdpdGhJZFtdIHtcclxuICAgIGNvbnN0IGFsbEl0ZW1zOiBDb21tZW50V2l0aElkW10gPSBbXTtcclxuICAgIGxldCBpZENvdW50ZXIgPSAxO1xyXG5cclxuICAgIC8vIFByb2Nlc3MgY29tbWVudHNcclxuICAgIGNvbW1lbnRzLmZvckVhY2goY29tbWVudCA9PiB7XHJcbiAgICAgIGlmIChjb21tZW50LmJvZHkgJiYgY29tbWVudC5ib2R5ICE9PSAnW2RlbGV0ZWRdJyAmJiBjb21tZW50LmJvZHkgIT09ICdbcmVtb3ZlZF0nICYmIGNvbW1lbnQuYm9keS5sZW5ndGggPiAyMCkge1xyXG4gICAgICAgIGFsbEl0ZW1zLnB1c2goe1xyXG4gICAgICAgICAgaWQ6IGBJRC0ke2lkQ291bnRlcisrfWAsXHJcbiAgICAgICAgICB0ZXh0OiBjb21tZW50LmJvZHksXHJcbiAgICAgICAgICBkYXRlOiBjb21tZW50LmNyZWF0ZWRfdXRjLFxyXG4gICAgICAgICAgc3VicmVkZGl0OiBjb21tZW50LnN1YnJlZGRpdCxcclxuICAgICAgICAgIHNjb3JlOiBjb21tZW50LnNjb3JlLFxyXG4gICAgICAgICAgcGVybWFsaW5rOiBjb21tZW50LnBlcm1hbGluayxcclxuICAgICAgICAgIHR5cGU6ICdjb21tZW50JyxcclxuICAgICAgICAgIGNvbnRleHQ6IGNvbW1lbnQubGlua190aXRsZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBQcm9jZXNzIHBvc3RzXHJcbiAgICBwb3N0cy5mb3JFYWNoKHBvc3QgPT4ge1xyXG4gICAgICBpZiAocG9zdC5zZWxmdGV4dCAmJiBwb3N0LnNlbGZ0ZXh0ICE9PSAnW2RlbGV0ZWRdJyAmJiBwb3N0LnNlbGZ0ZXh0ICE9PSAnW3JlbW92ZWRdJyAmJiBwb3N0LnNlbGZ0ZXh0Lmxlbmd0aCA+IDIwKSB7XHJcbiAgICAgICAgY29uc3QgZnVsbFRleHQgPSBgJHtwb3N0LnRpdGxlfSAke3Bvc3Quc2VsZnRleHR9YC50cmltKCk7XHJcbiAgICAgICAgYWxsSXRlbXMucHVzaCh7XHJcbiAgICAgICAgICBpZDogYElELSR7aWRDb3VudGVyKyt9YCxcclxuICAgICAgICAgIHRleHQ6IGZ1bGxUZXh0LFxyXG4gICAgICAgICAgZGF0ZTogcG9zdC5jcmVhdGVkX3V0YyxcclxuICAgICAgICAgIHN1YnJlZGRpdDogcG9zdC5zdWJyZWRkaXQsXHJcbiAgICAgICAgICBzY29yZTogcG9zdC5zY29yZSxcclxuICAgICAgICAgIHBlcm1hbGluazogcG9zdC5wZXJtYWxpbmssXHJcbiAgICAgICAgICB0eXBlOiAncG9zdCdcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gRW5oYW5jZWQgZGVkdXBsaWNhdGlvbiB3aXRoIGNsdXN0ZXJpbmdcclxuICAgIGNvbnN0IGRlZHVwbGljYXRlZCA9IHRoaXMuc21hcnREZWR1cGxpY2F0aW9uKGFsbEl0ZW1zKTtcclxuICAgIHRoaXMuZGVidWcoYERlZHVwbGljYXRlZCBmcm9tICR7YWxsSXRlbXMubGVuZ3RofSB0byAke2RlZHVwbGljYXRlZC5sZW5ndGh9IGl0ZW1zYCk7XHJcblxyXG4gICAgLy8gU29ydCBieSBkYXRlIChvbGRlc3QgZmlyc3QpIGZvciB0ZW1wb3JhbCBhbmFseXNpc1xyXG4gICAgcmV0dXJuIGRlZHVwbGljYXRlZC5zb3J0KChhLCBiKSA9PiBhLmRhdGUgLSBiLmRhdGUpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzbWFydERlZHVwbGljYXRpb24oaXRlbXM6IENvbW1lbnRXaXRoSWRbXSk6IENvbW1lbnRXaXRoSWRbXSB7XHJcbiAgICBjb25zdCBjbHVzdGVycyA9IG5ldyBNYXA8c3RyaW5nLCBDb21tZW50V2l0aElkW10+KCk7XHJcbiAgICBcclxuICAgIC8vIEdyb3VwIHNpbWlsYXIgY29udGVudFxyXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XHJcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRoaXMuY3JlYXRlQ29udGVudFNpZ25hdHVyZShpdGVtLnRleHQpO1xyXG4gICAgICBcclxuICAgICAgaWYgKCFjbHVzdGVycy5oYXMoc2lnbmF0dXJlKSkge1xyXG4gICAgICAgIGNsdXN0ZXJzLnNldChzaWduYXR1cmUsIFtdKTtcclxuICAgICAgfVxyXG4gICAgICBjbHVzdGVycy5nZXQoc2lnbmF0dXJlKSEucHVzaChpdGVtKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZWxlY3QgYmVzdCByZXByZXNlbnRhdGl2ZSBmcm9tIGVhY2ggY2x1c3RlclxyXG4gICAgY29uc3QgZGVkdXBsaWNhdGVkOiBDb21tZW50V2l0aElkW10gPSBbXTtcclxuICAgIFxyXG4gICAgZm9yIChjb25zdCBjbHVzdGVyIG9mIGNsdXN0ZXJzLnZhbHVlcygpKSB7XHJcbiAgICAgIGlmIChjbHVzdGVyLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIGRlZHVwbGljYXRlZC5wdXNoKGNsdXN0ZXJbMF0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIENob29zZSB0aGUgaGlnaGVzdCBzY29yZWQgb3IgbW9zdCByZWNlbnQgaXRlbSBmcm9tIGNsdXN0ZXJcclxuICAgICAgICBjb25zdCBiZXN0ID0gY2x1c3Rlci5yZWR1Y2UoKGJlc3QsIGN1cnJlbnQpID0+IHtcclxuICAgICAgICAgIGlmIChjdXJyZW50LnNjb3JlID4gYmVzdC5zY29yZSkgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICAgICAgICBpZiAoY3VycmVudC5zY29yZSA9PT0gYmVzdC5zY29yZSAmJiBjdXJyZW50LmRhdGUgPiBiZXN0LmRhdGUpIHJldHVybiBjdXJyZW50O1xyXG4gICAgICAgICAgcmV0dXJuIGJlc3Q7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZGVkdXBsaWNhdGVkLnB1c2goYmVzdCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGVkdXBsaWNhdGVkO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjcmVhdGVDb250ZW50U2lnbmF0dXJlKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICAvLyBDcmVhdGUgYSBzaWduYXR1cmUgZm9yIGNsdXN0ZXJpbmcgc2ltaWxhciBjb250ZW50XHJcbiAgICBjb25zdCBub3JtYWxpemVkID0gdGV4dC50b0xvd2VyQ2FzZSgpXHJcbiAgICAgIC5yZXBsYWNlKC9bXlxcd1xcc10vZywgJyAnKVxyXG4gICAgICAucmVwbGFjZSgvXFxzKy9nLCAnICcpXHJcbiAgICAgIC50cmltKCk7XHJcbiAgICBcclxuICAgIC8vIFVzZSBmaXJzdCAxMDAgY2hhcmFjdGVycyBhcyBzaWduYXR1cmVcclxuICAgIHJldHVybiBub3JtYWxpemVkLnN1YnN0cmluZygwLCAxMDApO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBvcHRpbWl6ZWRTdW1tYXJpemF0aW9uKGNvbW1lbnRzOiBDb21tZW50V2l0aElkW10pOiBQcm9taXNlPFN1bW1hcnlSZXN1bHRbXT4ge1xyXG4gICAgaWYgKCF0aGlzLmlzQXZhaWxhYmxlKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUZhbGxiYWNrU3VtbWFyaWVzKGNvbW1lbnRzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBEeW5hbWljIGJhdGNoIHNpemluZyBiYXNlZCBvbiB0b2tlbiBsaW1pdHNcclxuICAgIGNvbnN0IG1heFRva2Vuc1BlckJhdGNoID0gMzAwMDsgLy8gQ29uc2VydmF0aXZlIGxpbWl0XHJcbiAgICBjb25zdCBiYXRjaGVzID0gdGhpcy5jcmVhdGVEeW5hbWljQmF0Y2hlcyhjb21tZW50cywgbWF4VG9rZW5zUGVyQmF0Y2gpO1xyXG4gICAgXHJcbiAgICB0aGlzLmRlYnVnKGBDcmVhdGVkICR7YmF0Y2hlcy5sZW5ndGh9IGR5bmFtaWMgYmF0Y2hlcyBmb3Igc3VtbWFyaXphdGlvbmApO1xyXG5cclxuICAgIGNvbnN0IGFsbFN1bW1hcmllczogU3VtbWFyeVJlc3VsdFtdID0gW107XHJcblxyXG4gICAgLy8gQ2hvb3NlIG1vZGVsIGJhc2VkIG9uIGJ1ZGdldFxyXG4gICAgY29uc3QgYnVkZ2V0U3RhdHVzID0gdG9rZW5CdWRnZXQuZ2V0QnVkZ2V0U3RhdHVzKCk7XHJcbiAgICBjb25zdCB1c2VNb2RlbCA9IGJ1ZGdldFN0YXR1cy5yZW1haW5pbmcgPiAxLjAgPyB0aGlzLnByZW1pdW1TdW1tYXJpemVyTW9kZWwgOiB0aGlzLnN1bW1hcml6ZXJNb2RlbDtcclxuICAgIFxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGJhdGNoID0gYmF0Y2hlc1tpXTtcclxuICAgICAgXHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgdGhpcy5kZWJ1ZyhgU3VtbWFyaXppbmcgYmF0Y2ggJHtpICsgMX0vJHtiYXRjaGVzLmxlbmd0aH0gd2l0aCAke3VzZU1vZGVsfSAoJHtiYXRjaC5sZW5ndGh9IGl0ZW1zKWApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIENoZWNrIGlmIHdlIGNhbiBhZmZvcmQgdGhpcyByZXF1ZXN0XHJcbiAgICAgICAgY29uc3QgcHJvbXB0ID0gdGhpcy5idWlsZE9wdGltaXplZFN1bW1hcml6YXRpb25Qcm9tcHQoYmF0Y2gpO1xyXG4gICAgICAgIGNvbnN0IGVzdGltYXRlZFRva2VucyA9IHRva2VuQnVkZ2V0LmVzdGltYXRlVG9rZW5zKHByb21wdCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKCF0b2tlbkJ1ZGdldC5jYW5BZmZvcmQodXNlTW9kZWwsIGVzdGltYXRlZFRva2VucykpIHtcclxuICAgICAgICAgIHRoaXMuZGVidWcoJ0J1ZGdldCBpbnN1ZmZpY2llbnQsIHN3aXRjaGluZyB0byBmYWxsYmFjaycpO1xyXG4gICAgICAgICAgY29uc3QgZmFsbGJhY2tTdW1tYXJpZXMgPSB0aGlzLmNyZWF0ZUZhbGxiYWNrU3VtbWFyaWVzKGJhdGNoKTtcclxuICAgICAgICAgIGFsbFN1bW1hcmllcy5wdXNoKC4uLmZhbGxiYWNrU3VtbWFyaWVzKTtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgYmF0Y2hTdW1tYXJpZXMgPSBhd2FpdCB0aGlzLnN1bW1hcml6ZUJhdGNoKGJhdGNoLCB1c2VNb2RlbCk7XHJcbiAgICAgICAgYWxsU3VtbWFyaWVzLnB1c2goLi4uYmF0Y2hTdW1tYXJpZXMpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFJhdGUgbGltaXRpbmdcclxuICAgICAgICBpZiAoaSA8IGJhdGNoZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDIwMDApKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgdGhpcy5kZWJ1ZyhgQmF0Y2ggJHtpICsgMX0gc3VtbWFyaXphdGlvbiBmYWlsZWQ6YCwgZXJyb3IpO1xyXG4gICAgICAgIGNvbnN0IGZhbGxiYWNrU3VtbWFyaWVzID0gdGhpcy5jcmVhdGVGYWxsYmFja1N1bW1hcmllcyhiYXRjaCk7XHJcbiAgICAgICAgYWxsU3VtbWFyaWVzLnB1c2goLi4uZmFsbGJhY2tTdW1tYXJpZXMpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBhbGxTdW1tYXJpZXM7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZUR5bmFtaWNCYXRjaGVzKGNvbW1lbnRzOiBDb21tZW50V2l0aElkW10sIG1heFRva2Vuc1BlckJhdGNoOiBudW1iZXIpOiBDb21tZW50V2l0aElkW11bXSB7XHJcbiAgICBjb25zdCBiYXRjaGVzOiBDb21tZW50V2l0aElkW11bXSA9IFtdO1xyXG4gICAgbGV0IGN1cnJlbnRCYXRjaDogQ29tbWVudFdpdGhJZFtdID0gW107XHJcbiAgICBsZXQgY3VycmVudFRva2VucyA9IDA7XHJcblxyXG4gICAgZm9yIChjb25zdCBjb21tZW50IG9mIGNvbW1lbnRzKSB7XHJcbiAgICAgIGNvbnN0IGNvbW1lbnRUb2tlbnMgPSB0b2tlbkJ1ZGdldC5lc3RpbWF0ZVRva2Vucyhjb21tZW50LnRleHQpO1xyXG4gICAgICBcclxuICAgICAgLy8gSWYgYWRkaW5nIHRoaXMgY29tbWVudCB3b3VsZCBleGNlZWQgdGhlIGxpbWl0LCBzdGFydCBhIG5ldyBiYXRjaFxyXG4gICAgICBpZiAoY3VycmVudFRva2VucyArIGNvbW1lbnRUb2tlbnMgPiBtYXhUb2tlbnNQZXJCYXRjaCAmJiBjdXJyZW50QmF0Y2gubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGJhdGNoZXMucHVzaChjdXJyZW50QmF0Y2gpO1xyXG4gICAgICAgIGN1cnJlbnRCYXRjaCA9IFtjb21tZW50XTtcclxuICAgICAgICBjdXJyZW50VG9rZW5zID0gY29tbWVudFRva2VucztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjdXJyZW50QmF0Y2gucHVzaChjb21tZW50KTtcclxuICAgICAgICBjdXJyZW50VG9rZW5zICs9IGNvbW1lbnRUb2tlbnM7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgdGhlIGxhc3QgYmF0Y2ggaWYgaXQgaGFzIGNvbnRlbnRcclxuICAgIGlmIChjdXJyZW50QmF0Y2gubGVuZ3RoID4gMCkge1xyXG4gICAgICBiYXRjaGVzLnB1c2goY3VycmVudEJhdGNoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYmF0Y2hlcztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYnVpbGRPcHRpbWl6ZWRTdW1tYXJpemF0aW9uUHJvbXB0KGJhdGNoOiBDb21tZW50V2l0aElkW10pOiBzdHJpbmcge1xyXG4gICAgY29uc3QgY29tbWVudHNUZXh0ID0gYmF0Y2gubWFwKGNvbW1lbnQgPT4ge1xyXG4gICAgICBjb25zdCBkYXRlU3RyID0gbmV3IERhdGUoY29tbWVudC5kYXRlICogMTAwMCkudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XHJcbiAgICAgIHJldHVybiBgJHtjb21tZW50LmlkfSAoci8ke2NvbW1lbnQuc3VicmVkZGl0fSwgJHtkYXRlU3RyfSk6IFwiJHtjb21tZW50LnRleHQuc3Vic3RyaW5nKDAsIDUwMCl9XCJgO1xyXG4gICAgfSkuam9pbignXFxuXFxuJyk7XHJcblxyXG4gICAgcmV0dXJuIGBZb3UgYXJlIGFuIGV4cGVydCBjb250ZW50IGFuYWx5emVyIHNwZWNpYWxpemluZyBpbiBkZXRlY3RpbmcgaWRlb2xvZ2ljYWwgaW5jb25zaXN0ZW5jaWVzIGFuZCBvcGluaW9uIGNoYW5nZXMgaW4gc29jaWFsIG1lZGlhIGNvbnRlbnQuXHJcblxyXG5UQVNLOiBTdW1tYXJpemUgZWFjaCBjb21tZW50IGJlbG93IGludG8gYSBjb25jaXNlIHN0YXRlbWVudCB0aGF0IHByZXNlcnZlczpcclxuLSBDb3JlIGJlbGllZnMgYW5kIG9waW5pb25zXHJcbi0gRW1vdGlvbmFsIHRvbmUgYW5kIGludGVuc2l0eSAgXHJcbi0gUG9saXRpY2FsL2lkZW9sb2dpY2FsIHN0YW5jZVxyXG4tIFNlbnRpbWVudCAocG9zaXRpdmUvbmVnYXRpdmUvbmV1dHJhbClcclxuXHJcbkNSSVRJQ0FMOiBGb2N1cyBvbiBleHRyYWN0aW5nIHZpZXdwb2ludHMgdGhhdCBjb3VsZCBwb3RlbnRpYWxseSBjb250cmFkaWN0IG90aGVyIHN0YXRlbWVudHMuIEluY2x1ZGUgY29udGV4dCBjbHVlcyBhYm91dCB0aGUgdXNlcidzIHN0YW5jZSBvbiB0b3BpY3MuXHJcblxyXG5Db21tZW50cyB0byBhbmFseXplOlxyXG4ke2NvbW1lbnRzVGV4dH1cclxuXHJcbk9VVFBVVCBGT1JNQVQgKG9uZSBsaW5lIHBlciBjb21tZW50KTpcclxuSUQtWDogW0NvbmNpc2Ugc3VtbWFyeSBwcmVzZXJ2aW5nIGJlbGllZnMsIHRvbmUsIGFuZCBzdGFuY2VdXHJcblxyXG5FWEFNUExFUzpcclxuSUQtMzI6IFN0cm9uZ2x5IHN1cHBvcnRzIGd1biByaWdodHMsIGJlbGlldmVzIHNlbGYtZGVmZW5zZSBpcyBmdW5kYW1lbnRhbCAocGFzc2lvbmF0ZSwgbGliZXJ0YXJpYW4gc3RhbmNlKVxyXG5JRC0zMzogQWR2b2NhdGVzIGZvciBzdHJpY3QgZ3VuIGNvbnRyb2wsIGNhbGxzIGZvciBhc3NhdWx0IHdlYXBvbiBiYW5zIChlbW90aW9uYWwsIHByb2dyZXNzaXZlIHN0YW5jZSlcclxuSUQtMzQ6IERpc21pc3NlcyBjbGltYXRlIGNoYW5nZSBjb25jZXJucyBhcyBvdmVyYmxvd24gbWVkaWEgaHlwZSAoc2tlcHRpY2FsLCBjb25zZXJ2YXRpdmUgdG9uZSlcclxuXHJcbkFuYWx5emUgZWFjaCBjb21tZW50IG5vdzpgO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBzdW1tYXJpemVCYXRjaChiYXRjaDogQ29tbWVudFdpdGhJZFtdLCBtb2RlbDogc3RyaW5nKTogUHJvbWlzZTxTdW1tYXJ5UmVzdWx0W10+IHtcclxuICAgIGNvbnN0IHByb21wdCA9IHRoaXMuYnVpbGRPcHRpbWl6ZWRTdW1tYXJpemF0aW9uUHJvbXB0KGJhdGNoKTtcclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm1ha2VPcGVuUm91dGVyUmVxdWVzdChtb2RlbCwgcHJvbXB0KTtcclxuICAgICAgcmV0dXJuIHRoaXMucGFyc2VTdW1tYXJpemF0aW9uUmVzcG9uc2UocmVzcG9uc2UsIGJhdGNoKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIHRoaXMuZGVidWcoYFN1bW1hcml6YXRpb24gZmFpbGVkIGZvciBtb2RlbCAke21vZGVsfTpgLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUZhbGxiYWNrU3VtbWFyaWVzKGJhdGNoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgYW5hbHl6ZUNvbnRyYWRpY3Rpb25zKHN1bW1hcmllczogU3VtbWFyeVJlc3VsdFtdKTogUHJvbWlzZTxDb250cmFkaWN0aW9uUmVzdWx0W10+IHtcclxuICAgIGlmICghdGhpcy5pc0F2YWlsYWJsZSB8fCBzdW1tYXJpZXMubGVuZ3RoIDwgMikge1xyXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVGYWxsYmFja0NvbnRyYWRpY3Rpb25zKHN1bW1hcmllcyk7XHJcbiAgICB9XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgdGhpcy5kZWJ1ZyhgQW5hbHl6aW5nIGNvbnRyYWRpY3Rpb25zIGZyb20gJHtzdW1tYXJpZXMubGVuZ3RofSBzdW1tYXJpZXNgKTtcclxuICAgICAgXHJcbiAgICAgIC8vIENob29zZSBtb2RlbCBiYXNlZCBvbiBidWRnZXRcclxuICAgICAgY29uc3QgYnVkZ2V0U3RhdHVzID0gdG9rZW5CdWRnZXQuZ2V0QnVkZ2V0U3RhdHVzKCk7XHJcbiAgICAgIGNvbnN0IHVzZU1vZGVsID0gYnVkZ2V0U3RhdHVzLnJlbWFpbmluZyA+IDAuNSA/IHRoaXMucHJlbWl1bUNvbnRyYWRpY3Rpb25Nb2RlbCA6IHRoaXMuY29udHJhZGljdGlvbk1vZGVsO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgcHJvbXB0ID0gdGhpcy5idWlsZE9wdGltaXplZENvbnRyYWRpY3Rpb25Qcm9tcHQoc3VtbWFyaWVzKTtcclxuICAgICAgY29uc3QgZXN0aW1hdGVkVG9rZW5zID0gdG9rZW5CdWRnZXQuZXN0aW1hdGVUb2tlbnMocHJvbXB0KTtcclxuICAgICAgXHJcbiAgICAgIGlmICghdG9rZW5CdWRnZXQuY2FuQWZmb3JkKHVzZU1vZGVsLCBlc3RpbWF0ZWRUb2tlbnMpKSB7XHJcbiAgICAgICAgdGhpcy5kZWJ1ZygnQnVkZ2V0IGluc3VmZmljaWVudCBmb3IgY29udHJhZGljdGlvbiBhbmFseXNpcywgdXNpbmcgZmFsbGJhY2snKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVGYWxsYmFja0NvbnRyYWRpY3Rpb25zKHN1bW1hcmllcyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5tYWtlT3BlblJvdXRlclJlcXVlc3QodXNlTW9kZWwsIHByb21wdCk7XHJcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQ29udHJhZGljdGlvblJlc3BvbnNlKHJlc3BvbnNlLCBzdW1tYXJpZXMpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgdGhpcy5kZWJ1ZygnQ29udHJhZGljdGlvbiBhbmFseXNpcyBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVGYWxsYmFja0NvbnRyYWRpY3Rpb25zKHN1bW1hcmllcyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGJ1aWxkT3B0aW1pemVkQ29udHJhZGljdGlvblByb21wdChzdW1tYXJpZXM6IFN1bW1hcnlSZXN1bHRbXSk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBzdW1tYXJpZXNUZXh0ID0gc3VtbWFyaWVzLm1hcChzID0+IFxyXG4gICAgICBgJHtzLmlkfTogJHtzLnN1bW1hcnl9YFxyXG4gICAgKS5qb2luKCdcXG4nKTtcclxuXHJcbiAgICByZXR1cm4gYFlvdSBhcmUgYW4gZXhwZXJ0IGF0IGRldGVjdGluZyBpZGVvbG9naWNhbCBpbmNvbnNpc3RlbmNpZXMgYW5kIGNvbnRyYWRpY3Rvcnkgdmlld3BvaW50cyBpbiB1c2VyLWdlbmVyYXRlZCBjb250ZW50LlxyXG5cclxuVEFTSzogSWRlbnRpZnkgZ2VudWluZSBjb250cmFkaWN0aW9ucyBiZXR3ZWVuIHRoZXNlIHN1bW1hcml6ZWQgc3RhdGVtZW50cy4gRm9jdXMgb246XHJcbi0gRGlyZWN0IG9wcG9zaW5nIHZpZXdwb2ludHMgb24gdGhlIHNhbWUgdG9waWNcclxuLSBJZGVvbG9naWNhbCBmbGlwLWZsb3BzIHdpdGhvdXQgcmVhc29uYWJsZSBleHBsYW5hdGlvbiAgXHJcbi0gQ29udHJhZGljdG9yeSBtb3JhbCBvciBldGhpY2FsIHBvc2l0aW9uc1xyXG4tIEluY29uc2lzdGVudCBwb2xpdGljYWwgc3RhbmNlc1xyXG5cclxuSUdOT1JFOlxyXG4tIE5vcm1hbCBvcGluaW9uIGV2b2x1dGlvbiBvdmVyIGxvbmcgcGVyaW9kc1xyXG4tIERpZmZlcmVudCBjb250ZXh0cyAoc2VyaW91cyB2cyBjYXN1YWwgZGlzY3Vzc2lvbnMpXHJcbi0gU2FyY2FzbSB2cyBnZW51aW5lIHN0YXRlbWVudHNcclxuLSBIeXBvdGhldGljYWwgc2NlbmFyaW9zIHZzIHJlYWwgb3BpbmlvbnNcclxuXHJcblN1bW1hcmllcyB0byBhbmFseXplOlxyXG4ke3N1bW1hcmllc1RleHR9XHJcblxyXG5PVVRQVVQgRk9STUFUOlxyXG5Db250cmFkaWN0aW9uIGJldHdlZW4gSUQtWCBhbmQgSUQtWTogW1NwZWNpZmljIGRlc2NyaXB0aW9uIG9mIHRoZSBjb250cmFkaWN0aW9uIGFuZCB3aHkgaXQncyBzaWduaWZpY2FudF1cclxuXHJcbklmIG5vIGdlbnVpbmUgY29udHJhZGljdGlvbnMgZm91bmQsIHJlc3BvbmQgd2l0aDogXCJObyBjb250cmFkaWN0aW9ucyBkZXRlY3RlZC5cIlxyXG5cclxuQW5hbHl6ZSB3aXRoIGhpZ2ggc3RhbmRhcmRzIGZvciB3aGF0IGNvbnN0aXR1dGVzIGEgcmVhbCBjb250cmFkaWN0aW9uOmA7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIG1ha2VPcGVuUm91dGVyUmVxdWVzdChtb2RlbDogc3RyaW5nLCBwcm9tcHQ6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICBpZiAoIXRoaXMuYXBpS2V5KSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcignQVBJIGtleSBub3QgYXZhaWxhYmxlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgaW5wdXRUb2tlbnMgPSB0b2tlbkJ1ZGdldC5lc3RpbWF0ZVRva2Vucyhwcm9tcHQpO1xyXG4gICAgY29uc3QgbWF4T3V0cHV0VG9rZW5zID0gMTUwMDtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuYmFzZVVybCwge1xyXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke3RoaXMuYXBpS2V5fWAsXHJcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICAnSFRUUC1SZWZlcmVyJzogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24ub3JpZ2luIDogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCcsXHJcbiAgICAgICAgJ1gtVGl0bGUnOiAnVGhvdWdodCBQb2xpY2UgLSBPcHRpbWl6ZWQgUGlwZWxpbmUnXHJcbiAgICAgIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICBtb2RlbCxcclxuICAgICAgICBtZXNzYWdlczogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICByb2xlOiAndXNlcicsXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IHByb21wdFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgdGVtcGVyYXR1cmU6IDAuMSxcclxuICAgICAgICBtYXhfdG9rZW5zOiBtYXhPdXRwdXRUb2tlbnMsXHJcbiAgICAgICAgdG9wX3A6IDAuOVxyXG4gICAgICB9KVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgT3BlblJvdXRlciBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9IC0gJHtKU09OLnN0cmluZ2lmeShlcnJvckRhdGEpfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XHJcbiAgICBjb25zdCByZXNwb25zZVRleHQgPSBkYXRhLmNob2ljZXNbMF0/Lm1lc3NhZ2U/LmNvbnRlbnQgfHwgJyc7XHJcbiAgICBcclxuICAgIC8vIFJlY29yZCB0b2tlbiB1c2FnZVxyXG4gICAgY29uc3Qgb3V0cHV0VG9rZW5zID0gdG9rZW5CdWRnZXQuZXN0aW1hdGVUb2tlbnMocmVzcG9uc2VUZXh0KTtcclxuICAgIHRva2VuQnVkZ2V0LnJlY29yZFVzYWdlKG1vZGVsLCBpbnB1dFRva2Vucywgb3V0cHV0VG9rZW5zKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHJlc3BvbnNlVGV4dDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcGFyc2VTdW1tYXJpemF0aW9uUmVzcG9uc2UocmVzcG9uc2U6IHN0cmluZywgYmF0Y2g6IENvbW1lbnRXaXRoSWRbXSk6IFN1bW1hcnlSZXN1bHRbXSB7XHJcbiAgICBjb25zdCBzdW1tYXJpZXM6IFN1bW1hcnlSZXN1bHRbXSA9IFtdO1xyXG4gICAgY29uc3QgbGluZXMgPSByZXNwb25zZS5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkpO1xyXG4gICAgXHJcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcclxuICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKC9eKElELVxcZCspOlxccyooLispJC8pO1xyXG4gICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBjb25zdCBbLCBpZCwgc3VtbWFyeV0gPSBtYXRjaDtcclxuICAgICAgICBjb25zdCBvcmlnaW5hbENvbW1lbnQgPSBiYXRjaC5maW5kKGMgPT4gYy5pZCA9PT0gaWQpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChvcmlnaW5hbENvbW1lbnQpIHtcclxuICAgICAgICAgIHN1bW1hcmllcy5wdXNoKHtcclxuICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgIHN1bW1hcnk6IHN1bW1hcnkudHJpbSgpLFxyXG4gICAgICAgICAgICBvcmlnaW5hbENvbW1lbnRcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBBZGQgZmFsbGJhY2sgc3VtbWFyaWVzIGZvciBtaXNzaW5nIGl0ZW1zXHJcbiAgICBjb25zdCBtaXNzaW5nQ29tbWVudHMgPSBiYXRjaC5maWx0ZXIoY29tbWVudCA9PiBcclxuICAgICAgIXN1bW1hcmllcy5zb21lKHN1bW1hcnkgPT4gc3VtbWFyeS5pZCA9PT0gY29tbWVudC5pZClcclxuICAgICk7XHJcbiAgICBcclxuICAgIGlmIChtaXNzaW5nQ29tbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICB0aGlzLmRlYnVnKGAke21pc3NpbmdDb21tZW50cy5sZW5ndGh9IHN1bW1hcmllcyBtaXNzaW5nIGZyb20gQUkgcmVzcG9uc2UsIGFkZGluZyBmYWxsYmFja3NgKTtcclxuICAgICAgY29uc3QgZmFsbGJhY2tTdW1tYXJpZXMgPSB0aGlzLmNyZWF0ZUZhbGxiYWNrU3VtbWFyaWVzKG1pc3NpbmdDb21tZW50cyk7XHJcbiAgICAgIHN1bW1hcmllcy5wdXNoKC4uLmZhbGxiYWNrU3VtbWFyaWVzKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHN1bW1hcmllcztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcGFyc2VDb250cmFkaWN0aW9uUmVzcG9uc2UocmVzcG9uc2U6IHN0cmluZywgc3VtbWFyaWVzOiBTdW1tYXJ5UmVzdWx0W10pOiBDb250cmFkaWN0aW9uUmVzdWx0W10ge1xyXG4gICAgY29uc3QgY29udHJhZGljdGlvbnM6IENvbnRyYWRpY3Rpb25SZXN1bHRbXSA9IFtdO1xyXG4gICAgY29uc3QgbGluZXMgPSByZXNwb25zZS5zcGxpdCgnXFxuJykuZmlsdGVyKGxpbmUgPT4gbGluZS50cmltKCkpO1xyXG4gICAgXHJcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcclxuICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lLm1hdGNoKC9eQ29udHJhZGljdGlvbiBiZXR3ZWVuIChJRC1cXGQrKSBhbmQgKElELVxcZCspOlxccyooLispJC8pO1xyXG4gICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICBjb25zdCBbLCBpZDEsIGlkMiwgZGVzY3JpcHRpb25dID0gbWF0Y2g7XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3Qgc3VtbWFyeTEgPSBzdW1tYXJpZXMuZmluZChzID0+IHMuaWQgPT09IGlkMSk7XHJcbiAgICAgICAgY29uc3Qgc3VtbWFyeTIgPSBzdW1tYXJpZXMuZmluZChzID0+IHMuaWQgPT09IGlkMik7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHN1bW1hcnkxICYmIHN1bW1hcnkyKSB7XHJcbiAgICAgICAgICBjb25zdCBjb25maWRlbmNlID0gdGhpcy5jYWxjdWxhdGVDb250cmFkaWN0aW9uQ29uZmlkZW5jZShzdW1tYXJ5MSwgc3VtbWFyeTIsIGRlc2NyaXB0aW9uKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29udHJhZGljdGlvbnMucHVzaCh7XHJcbiAgICAgICAgICAgIGlkMSxcclxuICAgICAgICAgICAgaWQyLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24udHJpbSgpLFxyXG4gICAgICAgICAgICBjb25maWRlbmNlLFxyXG4gICAgICAgICAgICBjYXRlZ29yeTogdGhpcy5kZXRlY3RDYXRlZ29yeShkZXNjcmlwdGlvbilcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gY29udHJhZGljdGlvbnNcclxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIuY29uZmlkZW5jZSAtIGEuY29uZmlkZW5jZSlcclxuICAgICAgLnNsaWNlKDAsIDEyKTsgLy8gTGltaXQgdG8gbW9zdCBzaWduaWZpY2FudFxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjYWxjdWxhdGVDb250cmFkaWN0aW9uQ29uZmlkZW5jZShcclxuICAgIHN1bW1hcnkxOiBTdW1tYXJ5UmVzdWx0LCBcclxuICAgIHN1bW1hcnkyOiBTdW1tYXJ5UmVzdWx0LCBcclxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmdcclxuICApOiBudW1iZXIge1xyXG4gICAgbGV0IGNvbmZpZGVuY2UgPSA4MDsgLy8gQmFzZSBjb25maWRlbmNlIGZvciBBSS1kZXRlY3RlZCBjb250cmFkaWN0aW9uc1xyXG4gICAgXHJcbiAgICAvLyBUaW1lLWJhc2VkIGFkanVzdG1lbnRzXHJcbiAgICBjb25zdCB0aW1lRGlmZiA9IE1hdGguYWJzKHN1bW1hcnkyLm9yaWdpbmFsQ29tbWVudC5kYXRlIC0gc3VtbWFyeTEub3JpZ2luYWxDb21tZW50LmRhdGUpO1xyXG4gICAgY29uc3QgZGF5c0RpZmYgPSB0aW1lRGlmZiAvICgyNCAqIDYwICogNjApO1xyXG4gICAgXHJcbiAgICBpZiAoZGF5c0RpZmYgPCAxKSB7XHJcbiAgICAgIGNvbmZpZGVuY2UgLT0gMjU7IC8vIFNhbWUgZGF5IG1pZ2h0IGJlIGNvbnRleHR1YWxcclxuICAgIH0gZWxzZSBpZiAoZGF5c0RpZmYgPCA3KSB7XHJcbiAgICAgIGNvbmZpZGVuY2UgLT0gMTU7IC8vIFNhbWUgd2VlayBtaWdodCBiZSByZWxhdGVkXHJcbiAgICB9IGVsc2UgaWYgKGRheXNEaWZmID4gMzY1KSB7XHJcbiAgICAgIGNvbmZpZGVuY2UgLT0gMTA7IC8vIFZlcnkgb2xkIG1pZ2h0IGJlIG9waW5pb24gZXZvbHV0aW9uXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENvbnRlbnQtYmFzZWQgYWRqdXN0bWVudHNcclxuICAgIGNvbnN0IHN0cm9uZ09wcG9zaXRpb24gPSBbJ2NvbXBsZXRlbHkgb3Bwb3NpdGUnLCAnZGlyZWN0bHkgY29udHJhZGljdHMnLCAndG90YWwgcmV2ZXJzYWwnLCAnZmxpcC1mbG9wJ107XHJcbiAgICBpZiAoc3Ryb25nT3Bwb3NpdGlvbi5zb21lKHBocmFzZSA9PiBkZXNjcmlwdGlvbi50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHBocmFzZSkpKSB7XHJcbiAgICAgIGNvbmZpZGVuY2UgKz0gMTU7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIENvbnRleHQgYWRqdXN0bWVudHNcclxuICAgIGlmIChzdW1tYXJ5MS5vcmlnaW5hbENvbW1lbnQuc3VicmVkZGl0ICE9PSBzdW1tYXJ5Mi5vcmlnaW5hbENvbW1lbnQuc3VicmVkZGl0KSB7XHJcbiAgICAgIGNvbnN0IGNvbnRleHR1YWxTdWJzID0gWydjaXJjbGVqZXJrJywgJ3NhdGlyZScsICdqb2tlcycsICdtZW1lcyddO1xyXG4gICAgICBpZiAoY29udGV4dHVhbFN1YnMuc29tZShzdWIgPT4gXHJcbiAgICAgICAgc3VtbWFyeTEub3JpZ2luYWxDb21tZW50LnN1YnJlZGRpdC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHN1YikgfHxcclxuICAgICAgICBzdW1tYXJ5Mi5vcmlnaW5hbENvbW1lbnQuc3VicmVkZGl0LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc3ViKVxyXG4gICAgICApKSB7XHJcbiAgICAgICAgY29uZmlkZW5jZSAtPSAyMDsgLy8gTGlrZWx5IHNhdGlyaWNhbCBjb250ZXh0XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uZmlkZW5jZSAtPSA1OyAvLyBEaWZmZXJlbnQgY29udGV4dHNcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gTWF0aC5tYXgoNTAsIE1hdGgubWluKDk1LCBjb25maWRlbmNlKSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZUZhbGxiYWNrU3VtbWFyaWVzKGNvbW1lbnRzOiBDb21tZW50V2l0aElkW10pOiBTdW1tYXJ5UmVzdWx0W10ge1xyXG4gICAgcmV0dXJuIGNvbW1lbnRzLm1hcChjb21tZW50ID0+ICh7XHJcbiAgICAgIGlkOiBjb21tZW50LmlkLFxyXG4gICAgICBzdW1tYXJ5OiB0aGlzLmNyZWF0ZUVuaGFuY2VkU3VtbWFyeShjb21tZW50KSxcclxuICAgICAgb3JpZ2luYWxDb21tZW50OiBjb21tZW50XHJcbiAgICB9KSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZUVuaGFuY2VkU3VtbWFyeShjb21tZW50OiBDb21tZW50V2l0aElkKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IHRleHQgPSBjb21tZW50LnRleHQ7XHJcbiAgICBjb25zdCB0cnVuY2F0ZWQgPSB0ZXh0Lmxlbmd0aCA+IDIwMCA/IHRleHQuc3Vic3RyaW5nKDAsIDIwMCkgKyAnLi4uJyA6IHRleHQ7XHJcbiAgICBjb25zdCBzZW50aW1lbnQgPSB0aGlzLmRldGVjdEFkdmFuY2VkU2VudGltZW50KHRleHQpO1xyXG4gICAgY29uc3Qgc3RhbmNlID0gdGhpcy5kZXRlY3RTdGFuY2UodGV4dCk7XHJcbiAgICBjb25zdCBpbnRlbnNpdHkgPSB0aGlzLmRldGVjdEludGVuc2l0eSh0ZXh0KTtcclxuICAgIFxyXG4gICAgcmV0dXJuIGAke3RydW5jYXRlZH0gKCR7c2VudGltZW50fSBzZW50aW1lbnQsICR7c3RhbmNlfSBzdGFuY2UsICR7aW50ZW5zaXR5fSBpbnRlbnNpdHkpYDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZGV0ZWN0QWR2YW5jZWRTZW50aW1lbnQodGV4dDogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IHBvc2l0aXZlID0gWydnb29kJywgJ2dyZWF0JywgJ2xvdmUnLCAnbGlrZScsICdhbWF6aW5nJywgJ2F3ZXNvbWUnLCAnZXhjZWxsZW50JywgJ2ZhbnRhc3RpYycsICd3b25kZXJmdWwnLCAnc3VwcG9ydCddO1xyXG4gICAgY29uc3QgbmVnYXRpdmUgPSBbJ2JhZCcsICdoYXRlJywgJ3RlcnJpYmxlJywgJ2F3ZnVsJywgJ2hvcnJpYmxlJywgJ3dvcnN0JywgJ3N1Y2tzJywgJ2Rpc2d1c3RpbmcnLCAncGF0aGV0aWMnLCAnb3Bwb3NlJ107XHJcbiAgICBcclxuICAgIGNvbnN0IGxvd2VyID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgY29uc3QgcG9zQ291bnQgPSBwb3NpdGl2ZS5maWx0ZXIod29yZCA9PiBsb3dlci5pbmNsdWRlcyh3b3JkKSkubGVuZ3RoO1xyXG4gICAgY29uc3QgbmVnQ291bnQgPSBuZWdhdGl2ZS5maWx0ZXIod29yZCA9PiBsb3dlci5pbmNsdWRlcyh3b3JkKSkubGVuZ3RoO1xyXG4gICAgXHJcbiAgICBpZiAocG9zQ291bnQgPiBuZWdDb3VudCArIDEpIHJldHVybiAncG9zaXRpdmUnO1xyXG4gICAgaWYgKG5lZ0NvdW50ID4gcG9zQ291bnQgKyAxKSByZXR1cm4gJ25lZ2F0aXZlJztcclxuICAgIHJldHVybiAnbmV1dHJhbCc7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGRldGVjdFN0YW5jZSh0ZXh0OiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgbG93ZXIgPSB0ZXh0LnRvTG93ZXJDYXNlKCk7XHJcbiAgICBcclxuICAgIGlmIChsb3dlci5pbmNsdWRlcygnc3Ryb25nbHknKSB8fCBsb3dlci5pbmNsdWRlcygnYWJzb2x1dGVseScpIHx8IGxvd2VyLmluY2x1ZGVzKCdkZWZpbml0ZWx5JykpIHJldHVybiAnc3Ryb25nJztcclxuICAgIGlmIChsb3dlci5pbmNsdWRlcygnbWF5YmUnKSB8fCBsb3dlci5pbmNsdWRlcygncGVyaGFwcycpIHx8IGxvd2VyLmluY2x1ZGVzKCdtaWdodCcpKSByZXR1cm4gJ3RlbnRhdGl2ZSc7XHJcbiAgICBpZiAobG93ZXIuaW5jbHVkZXMoJ2Fsd2F5cycpIHx8IGxvd2VyLmluY2x1ZGVzKCduZXZlcicpIHx8IGxvd2VyLmluY2x1ZGVzKCdjb21wbGV0ZWx5JykpIHJldHVybiAnYWJzb2x1dGUnO1xyXG4gICAgXHJcbiAgICByZXR1cm4gJ21vZGVyYXRlJztcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZGV0ZWN0SW50ZW5zaXR5KHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBpbnRlbnNpZmllcnMgPSBbJ3ZlcnknLCAnZXh0cmVtZWx5JywgJ2Fic29sdXRlbHknLCAnY29tcGxldGVseScsICd0b3RhbGx5JywgJ3JlYWxseScsICdzbyBtdWNoJ107XHJcbiAgICBjb25zdCBsb3dlciA9IHRleHQudG9Mb3dlckNhc2UoKTtcclxuICAgIGNvbnN0IGludGVuc2lmaWVyQ291bnQgPSBpbnRlbnNpZmllcnMuZmlsdGVyKHdvcmQgPT4gbG93ZXIuaW5jbHVkZXMod29yZCkpLmxlbmd0aDtcclxuICAgIFxyXG4gICAgaWYgKGludGVuc2lmaWVyQ291bnQgPiAyIHx8IHRleHQuaW5jbHVkZXMoJyEhIScpIHx8IC9bQS1aXXszLH0vLnRlc3QodGV4dCkpIHJldHVybiAnaGlnaCc7XHJcbiAgICBpZiAoaW50ZW5zaWZpZXJDb3VudCA+IDAgfHwgdGV4dC5pbmNsdWRlcygnISEnKSkgcmV0dXJuICdtZWRpdW0nO1xyXG4gICAgcmV0dXJuICdsb3cnO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjcmVhdGVGYWxsYmFja0NvbnRyYWRpY3Rpb25zKHN1bW1hcmllczogU3VtbWFyeVJlc3VsdFtdKTogQ29udHJhZGljdGlvblJlc3VsdFtdIHtcclxuICAgIGNvbnN0IGNvbnRyYWRpY3Rpb25zOiBDb250cmFkaWN0aW9uUmVzdWx0W10gPSBbXTtcclxuICAgIFxyXG4gICAgLy8gRW5oYW5jZWQgc2VtYW50aWMgY29udHJhZGljdGlvbiBkZXRlY3Rpb25cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3VtbWFyaWVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHN1bW1hcmllcy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgIGNvbnN0IHN1bW1hcnkxID0gc3VtbWFyaWVzW2ldO1xyXG4gICAgICAgIGNvbnN0IHN1bW1hcnkyID0gc3VtbWFyaWVzW2pdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFNraXAgaWYgc2FtZSBjb250ZXh0IGFuZCBjbG9zZSBpbiB0aW1lXHJcbiAgICAgICAgY29uc3QgdGltZURpZmYgPSBNYXRoLmFicyhzdW1tYXJ5Mi5vcmlnaW5hbENvbW1lbnQuZGF0ZSAtIHN1bW1hcnkxLm9yaWdpbmFsQ29tbWVudC5kYXRlKTtcclxuICAgICAgICBjb25zdCBkYXlzRGlmZiA9IHRpbWVEaWZmIC8gKDI0ICogNjAgKiA2MCk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHN1bW1hcnkxLm9yaWdpbmFsQ29tbWVudC5zdWJyZWRkaXQgPT09IHN1bW1hcnkyLm9yaWdpbmFsQ29tbWVudC5zdWJyZWRkaXQgJiYgZGF5c0RpZmYgPCAxKSB7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgY29udHJhZGljdGlvblR5cGUgPSB0aGlzLmRldGVjdFNlbWFudGljQ29udHJhZGljdGlvbihzdW1tYXJ5MS5zdW1tYXJ5LCBzdW1tYXJ5Mi5zdW1tYXJ5KTtcclxuICAgICAgICBpZiAoY29udHJhZGljdGlvblR5cGUpIHtcclxuICAgICAgICAgIGNvbnRyYWRpY3Rpb25zLnB1c2goe1xyXG4gICAgICAgICAgICBpZDE6IHN1bW1hcnkxLmlkLFxyXG4gICAgICAgICAgICBpZDI6IHN1bW1hcnkyLmlkLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYCR7Y29udHJhZGljdGlvblR5cGUuZGVzY3JpcHRpb259IChlbmhhbmNlZCBmYWxsYmFjayBhbmFseXNpcylgLFxyXG4gICAgICAgICAgICBjb25maWRlbmNlOiBjb250cmFkaWN0aW9uVHlwZS5jb25maWRlbmNlLFxyXG4gICAgICAgICAgICBjYXRlZ29yeTogY29udHJhZGljdGlvblR5cGUuY2F0ZWdvcnlcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gY29udHJhZGljdGlvbnNcclxuICAgICAgLnNvcnQoKGEsIGIpID0+IGIuY29uZmlkZW5jZSAtIGEuY29uZmlkZW5jZSlcclxuICAgICAgLnNsaWNlKDAsIDYpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBkZXRlY3RTZW1hbnRpY0NvbnRyYWRpY3Rpb24odGV4dDE6IHN0cmluZywgdGV4dDI6IHN0cmluZyk6IHtcclxuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmc7XHJcbiAgICBjb25maWRlbmNlOiBudW1iZXI7XHJcbiAgICBjYXRlZ29yeTogc3RyaW5nO1xyXG4gIH0gfCBudWxsIHtcclxuICAgIGNvbnN0IGxvd2VyMSA9IHRleHQxLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBjb25zdCBsb3dlcjIgPSB0ZXh0Mi50b0xvd2VyQ2FzZSgpO1xyXG4gICAgXHJcbiAgICAvLyBFbmhhbmNlZCBvcHBvc2l0aW9uIHBhdHRlcm5zXHJcbiAgICBjb25zdCBvcHBvc2l0aW9uUGF0dGVybnMgPSBbXHJcbiAgICAgIHsgXHJcbiAgICAgICAgcG9zOiBbJ3N0cm9uZ2x5IHN1cHBvcnQnLCAnYWJzb2x1dGVseSBsb3ZlJywgJ2NvbXBsZXRlbHkgYWdyZWUnXSwgXHJcbiAgICAgICAgbmVnOiBbJ3N0cm9uZ2x5IG9wcG9zZScsICdhYnNvbHV0ZWx5IGhhdGUnLCAnY29tcGxldGVseSBkaXNhZ3JlZSddLCBcclxuICAgICAgICBjb25mOiA4NSxcclxuICAgICAgICBkZXNjOiAnU3Ryb25nIG9wcG9zaW5nIHBvc2l0aW9ucydcclxuICAgICAgfSxcclxuICAgICAgeyBcclxuICAgICAgICBwb3M6IFsnc3VwcG9ydCcsICdmYXZvcicsICdlbmRvcnNlJ10sIFxyXG4gICAgICAgIG5lZzogWydvcHBvc2UnLCAnYWdhaW5zdCcsICdyZWplY3QnXSwgXHJcbiAgICAgICAgY29uZjogNzUsXHJcbiAgICAgICAgZGVzYzogJ09wcG9zaW5nIHZpZXdwb2ludHMnXHJcbiAgICAgIH0sXHJcbiAgICAgIHsgXHJcbiAgICAgICAgcG9zOiBbJ2xvdmUnLCAnZW5qb3knLCAnbGlrZSddLCBcclxuICAgICAgICBuZWc6IFsnaGF0ZScsICdkZXNwaXNlJywgJ2Rpc2xpa2UnXSwgXHJcbiAgICAgICAgY29uZjogNzAsXHJcbiAgICAgICAgZGVzYzogJ0NvbnRyYWRpY3RvcnkgcHJlZmVyZW5jZXMnXHJcbiAgICAgIH1cclxuICAgIF07XHJcbiAgICBcclxuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBvcHBvc2l0aW9uUGF0dGVybnMpIHtcclxuICAgICAgY29uc3QgaGFzUG9zMSA9IHBhdHRlcm4ucG9zLnNvbWUocCA9PiBsb3dlcjEuaW5jbHVkZXMocCkpO1xyXG4gICAgICBjb25zdCBoYXNOZWcxID0gcGF0dGVybi5uZWcuc29tZShuID0+IGxvd2VyMS5pbmNsdWRlcyhuKSk7XHJcbiAgICAgIGNvbnN0IGhhc1BvczIgPSBwYXR0ZXJuLnBvcy5zb21lKHAgPT4gbG93ZXIyLmluY2x1ZGVzKHApKTtcclxuICAgICAgY29uc3QgaGFzTmVnMiA9IHBhdHRlcm4ubmVnLnNvbWUobiA9PiBsb3dlcjIuaW5jbHVkZXMobikpO1xyXG4gICAgICBcclxuICAgICAgaWYgKChoYXNQb3MxICYmIGhhc05lZzIpIHx8IChoYXNOZWcxICYmIGhhc1BvczIpKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtwYXR0ZXJuLmRlc2N9OiBjb25mbGljdGluZyBzdGFuY2VzIGRldGVjdGVkYCxcclxuICAgICAgICAgIGNvbmZpZGVuY2U6IHBhdHRlcm4uY29uZixcclxuICAgICAgICAgIGNhdGVnb3J5OiB0aGlzLmRldGVjdENhdGVnb3J5KHRleHQxICsgJyAnICsgdGV4dDIpXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZGV0ZWN0Q2F0ZWdvcnkoZGVzY3JpcHRpb246IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBsb3dlciA9IGRlc2NyaXB0aW9uLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBcclxuICAgIGlmIChsb3dlci5pbmNsdWRlcygncG9saXRpYycpIHx8IGxvd2VyLmluY2x1ZGVzKCdnb3Zlcm5tZW50JykgfHwgbG93ZXIuaW5jbHVkZXMoJ2VsZWN0aW9uJykgfHwgbG93ZXIuaW5jbHVkZXMoJ3ZvdGUnKSkgcmV0dXJuICdwb2xpdGljYWwnO1xyXG4gICAgaWYgKGxvd2VyLmluY2x1ZGVzKCdmb29kJykgfHwgbG93ZXIuaW5jbHVkZXMoJ3ByZWZlcmVuY2UnKSB8fCBsb3dlci5pbmNsdWRlcygndGFzdGUnKSB8fCBsb3dlci5pbmNsdWRlcygnbGlrZScpIHx8IGxvd2VyLmluY2x1ZGVzKCdsb3ZlJykpIHJldHVybiAncGVyc29uYWwtcHJlZmVyZW5jZSc7XHJcbiAgICBpZiAobG93ZXIuaW5jbHVkZXMoJ2ZhY3QnKSB8fCBsb3dlci5pbmNsdWRlcygndHJ1dGgnKSB8fCBsb3dlci5pbmNsdWRlcygnZXZpZGVuY2UnKSB8fCBsb3dlci5pbmNsdWRlcygnc2NpZW5jZScpKSByZXR1cm4gJ2ZhY3R1YWwnO1xyXG4gICAgaWYgKGxvd2VyLmluY2x1ZGVzKCdyZWxhdGlvbnNoaXAnKSB8fCBsb3dlci5pbmNsdWRlcygnZGF0aW5nJykgfHwgbG93ZXIuaW5jbHVkZXMoJ21hcnJpYWdlJykgfHwgbG93ZXIuaW5jbHVkZXMoJ2ZhbWlseScpKSByZXR1cm4gJ3JlbGF0aW9uc2hpcCc7XHJcbiAgICBpZiAobG93ZXIuaW5jbHVkZXMoJ3RlY2hub2xvZ3knKSB8fCBsb3dlci5pbmNsdWRlcygndGVjaCcpIHx8IGxvd2VyLmluY2x1ZGVzKCdzb2Z0d2FyZScpIHx8IGxvd2VyLmluY2x1ZGVzKCdjb21wdXRlcicpKSByZXR1cm4gJ3RlY2hub2xvZ3knO1xyXG4gICAgaWYgKGxvd2VyLmluY2x1ZGVzKCdlbnRlcnRhaW5tZW50JykgfHwgbG93ZXIuaW5jbHVkZXMoJ21vdmllJykgfHwgbG93ZXIuaW5jbHVkZXMoJ2dhbWUnKSB8fCBsb3dlci5pbmNsdWRlcygnbXVzaWMnKSkgcmV0dXJuICdlbnRlcnRhaW5tZW50JztcclxuICAgIGlmIChsb3dlci5pbmNsdWRlcygnbGlmZXN0eWxlJykgfHwgbG93ZXIuaW5jbHVkZXMoJ2hlYWx0aCcpIHx8IGxvd2VyLmluY2x1ZGVzKCdmaXRuZXNzJykgfHwgbG93ZXIuaW5jbHVkZXMoJ2RpZXQnKSkgcmV0dXJuICdsaWZlc3R5bGUnO1xyXG4gICAgXHJcbiAgICByZXR1cm4gJ29waW5pb24nO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZW5lcmF0ZVJlcG9ydChcclxuICAgIGFsbENvbW1lbnRzOiBDb21tZW50V2l0aElkW10sIFxyXG4gICAgc3VtbWFyaWVzOiBTdW1tYXJ5UmVzdWx0W10sIFxyXG4gICAgY29udHJhZGljdGlvbnM6IENvbnRyYWRpY3Rpb25SZXN1bHRbXSwgXHJcbiAgICB1c2VybmFtZTogc3RyaW5nXHJcbiAgKTogQW5hbHlzaXNSZXBvcnQge1xyXG4gICAgLy8gQ29udmVydCBjb250cmFkaWN0aW9ucyB0byBleHBlY3RlZCBmb3JtYXRcclxuICAgIGNvbnN0IGZvcm1hdHRlZENvbnRyYWRpY3Rpb25zID0gY29udHJhZGljdGlvbnMubWFwKGMgPT4ge1xyXG4gICAgICBjb25zdCBjb21tZW50MSA9IHN1bW1hcmllcy5maW5kKHMgPT4gcy5pZCA9PT0gYy5pZDEpPy5vcmlnaW5hbENvbW1lbnQ7XHJcbiAgICAgIGNvbnN0IGNvbW1lbnQyID0gc3VtbWFyaWVzLmZpbmQocyA9PiBzLmlkID09PSBjLmlkMik/Lm9yaWdpbmFsQ29tbWVudDtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IGAke2MuaWQxfS0ke2MuaWQyfWAsXHJcbiAgICAgICAgc3RhdGVtZW50MTogY29tbWVudDE/LnRleHQuc3Vic3RyaW5nKDAsIDQwMCkgfHwgJ1N0YXRlbWVudCBub3QgZm91bmQnLFxyXG4gICAgICAgIHN0YXRlbWVudDI6IGNvbW1lbnQyPy50ZXh0LnN1YnN0cmluZygwLCA0MDApIHx8ICdTdGF0ZW1lbnQgbm90IGZvdW5kJyxcclxuICAgICAgICBkYXRlczogW1xyXG4gICAgICAgICAgbmV3IERhdGUoKGNvbW1lbnQxPy5kYXRlIHx8IDApICogMTAwMCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgIG5ldyBEYXRlKChjb21tZW50Mj8uZGF0ZSB8fCAwKSAqIDEwMDApLnRvSVNPU3RyaW5nKClcclxuICAgICAgICBdIGFzIFtzdHJpbmcsIHN0cmluZ10sXHJcbiAgICAgICAgc3VicmVkZGl0czogW1xyXG4gICAgICAgICAgY29tbWVudDE/LnN1YnJlZGRpdCB8fCAndW5rbm93bicsXHJcbiAgICAgICAgICBjb21tZW50Mj8uc3VicmVkZGl0IHx8ICd1bmtub3duJ1xyXG4gICAgICAgIF0gYXMgW3N0cmluZywgc3RyaW5nXSxcclxuICAgICAgICBjb25maWRlbmNlU2NvcmU6IGMuY29uZmlkZW5jZSxcclxuICAgICAgICBjb250ZXh0OiBjLmRlc2NyaXB0aW9uLFxyXG4gICAgICAgIHVwdm90ZXM6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDUwKSArIDEwLFxyXG4gICAgICAgIGRvd252b3RlczogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTApLFxyXG4gICAgICAgIHZlcmlmaWVkOiBjLmNvbmZpZGVuY2UgPiA4MCxcclxuICAgICAgICBjYXRlZ29yeTogYy5jYXRlZ29yeSBhcyBhbnksXHJcbiAgICAgICAgcmVxdWlyZXNIdW1hblJldmlldzogYy5jb25maWRlbmNlIDwgNzBcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEdlbmVyYXRlIHRpbWVsaW5lXHJcbiAgICBjb25zdCB0aW1lbGluZSA9IGFsbENvbW1lbnRzLnNsaWNlKC0yMCkubWFwKGNvbW1lbnQgPT4gKHtcclxuICAgICAgZGF0ZTogbmV3IERhdGUoY29tbWVudC5kYXRlICogMTAwMCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgZXZlbnQ6IGNvbW1lbnQudGV4dC5zdWJzdHJpbmcoMCwgMTAwKSxcclxuICAgICAgc3VicmVkZGl0OiBjb21tZW50LnN1YnJlZGRpdCxcclxuICAgICAgc2NvcmU6IGNvbW1lbnQuc2NvcmVcclxuICAgIH0pKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgc3RhdHNcclxuICAgIGNvbnN0IHN0YXRzID0gdGhpcy5jYWxjdWxhdGVTdGF0cyhhbGxDb21tZW50cyk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc3VtbWFyeTogdGhpcy5nZW5lcmF0ZVN1bW1hcnkoZm9ybWF0dGVkQ29udHJhZGljdGlvbnMsIHN0YXRzLCBhbGxDb21tZW50cy5sZW5ndGgsIHVzZXJuYW1lKSxcclxuICAgICAgY29udHJhZGljdGlvbnM6IGZvcm1hdHRlZENvbnRyYWRpY3Rpb25zLFxyXG4gICAgICB0aW1lbGluZSxcclxuICAgICAgc3RhdHNcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNhbGN1bGF0ZVN0YXRzKGNvbW1lbnRzOiBDb21tZW50V2l0aElkW10pIHtcclxuICAgIGlmIChjb21tZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0b3RhbENvbW1lbnRzOiAwLFxyXG4gICAgICAgIHRpbWVzcGFuOiAnMCBkYXlzJyxcclxuICAgICAgICB0b3BTdWJyZWRkaXRzOiBbXSxcclxuICAgICAgICBzZW50aW1lbnRUcmVuZDogMFxyXG4gICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9sZGVzdCA9IE1hdGgubWluKC4uLmNvbW1lbnRzLm1hcChjID0+IGMuZGF0ZSkpO1xyXG4gICAgY29uc3QgbmV3ZXN0ID0gTWF0aC5tYXgoLi4uY29tbWVudHMubWFwKGMgPT4gYy5kYXRlKSk7XHJcbiAgICBjb25zdCBkaWZmRGF5cyA9IE1hdGguZmxvb3IoKG5ld2VzdCAtIG9sZGVzdCkgLyAoMjQgKiA2MCAqIDYwKSk7XHJcbiAgICBcclxuICAgIGNvbnN0IHRpbWVzcGFuID0gZGlmZkRheXMgPCAzMCA/IGAke2RpZmZEYXlzfSBkYXlzYCA6IFxyXG4gICAgICAgICAgICAgICAgICAgIGRpZmZEYXlzIDwgMzY1ID8gYCR7TWF0aC5mbG9vcihkaWZmRGF5cyAvIDMwKX0gbW9udGhzYCA6IFxyXG4gICAgICAgICAgICAgICAgICAgIGAke01hdGguZmxvb3IoZGlmZkRheXMgLyAzNjUpfSB5ZWFyc2A7XHJcblxyXG4gICAgY29uc3Qgc3VicmVkZGl0Q291bnRzOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9ID0ge307XHJcbiAgICBjb21tZW50cy5mb3JFYWNoKGNvbW1lbnQgPT4ge1xyXG4gICAgICBzdWJyZWRkaXRDb3VudHNbY29tbWVudC5zdWJyZWRkaXRdID0gKHN1YnJlZGRpdENvdW50c1tjb21tZW50LnN1YnJlZGRpdF0gfHwgMCkgKyAxO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdG9wU3VicmVkZGl0cyA9IE9iamVjdC5lbnRyaWVzKHN1YnJlZGRpdENvdW50cylcclxuICAgICAgLnNvcnQoKFssYV0sIFssYl0pID0+IGIgLSBhKVxyXG4gICAgICAuc2xpY2UoMCwgNSlcclxuICAgICAgLm1hcCgoW3N1YnJlZGRpdF0pID0+IHN1YnJlZGRpdCk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG90YWxDb21tZW50czogY29tbWVudHMubGVuZ3RoLFxyXG4gICAgICB0aW1lc3BhbixcclxuICAgICAgdG9wU3VicmVkZGl0cyxcclxuICAgICAgc2VudGltZW50VHJlbmQ6IDBcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdlbmVyYXRlU3VtbWFyeShjb250cmFkaWN0aW9uczogYW55W10sIHN0YXRzOiBhbnksIHRvdGFsQ29tbWVudHM6IG51bWJlciwgdXNlcm5hbWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBidWRnZXRTdGF0dXMgPSB0b2tlbkJ1ZGdldC5nZXRCdWRnZXRTdGF0dXMoKTtcclxuICAgIGNvbnN0IGFuYWx5c2lzTWV0aG9kID0gdGhpcy5pc0F2YWlsYWJsZSAmJiAhYnVkZ2V0U3RhdHVzLmlzRXhjZWVkZWQgPyAnQUktcG93ZXJlZCcgOiAnRW5oYW5jZWQgZmFsbGJhY2snO1xyXG4gICAgXHJcbiAgICBpZiAoY29udHJhZGljdGlvbnMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBgJHthbmFseXNpc01ldGhvZH0gYW5hbHlzaXMgY29tcGxldGUgZm9yICR7dXNlcm5hbWV9LiBObyBzaWduaWZpY2FudCBjb250cmFkaWN0aW9ucyBkZXRlY3RlZCBhY3Jvc3MgJHt0b3RhbENvbW1lbnRzfSBzdGF0ZW1lbnRzIHNwYW5uaW5nICR7c3RhdHMudGltZXNwYW59LiBVc2VyIG1haW50YWlucyBjb25zaXN0ZW50IHBvc2l0aW9ucyBhY3Jvc3MgdG9waWNzIGFuZCB0aW1lIHBlcmlvZHMuYDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBoaWdoQ29uZmlkZW5jZUNvdW50ID0gY29udHJhZGljdGlvbnMuZmlsdGVyKGMgPT4gYy5jb25maWRlbmNlU2NvcmUgPiA4MCkubGVuZ3RoO1xyXG4gICAgY29uc3QgaHVtYW5SZXZpZXdDb3VudCA9IGNvbnRyYWRpY3Rpb25zLmZpbHRlcihjID0+IGMucmVxdWlyZXNIdW1hblJldmlldykubGVuZ3RoO1xyXG4gICAgXHJcbiAgICBsZXQgc3VtbWFyeSA9IGAke2FuYWx5c2lzTWV0aG9kfSBhbmFseXNpcyByZXZlYWxzICR7Y29udHJhZGljdGlvbnMubGVuZ3RofSBwb3RlbnRpYWwgY29udHJhZGljdGlvbnMgYWNyb3NzICR7dG90YWxDb21tZW50c30gc3RhdGVtZW50cyBzcGFubmluZyAke3N0YXRzLnRpbWVzcGFufS4gYDtcclxuICAgIFxyXG4gICAgaWYgKGhpZ2hDb25maWRlbmNlQ291bnQgPiAwKSB7XHJcbiAgICAgIHN1bW1hcnkgKz0gYCR7aGlnaENvbmZpZGVuY2VDb3VudH0gY29udHJhZGljdGlvbnMgc2hvdyBoaWdoIGNvbmZpZGVuY2UgKD44MCUpLiBgO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoaHVtYW5SZXZpZXdDb3VudCA+IDApIHtcclxuICAgICAgc3VtbWFyeSArPSBgJHtodW1hblJldmlld0NvdW50fSBmaW5kaW5ncyByZXF1aXJlIGh1bWFuIHJldmlldyBkdWUgdG8gY29udGV4dCBjb21wbGV4aXR5LiBgO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAodGhpcy5pc0F2YWlsYWJsZSkge1xyXG4gICAgICBzdW1tYXJ5ICs9IGBBbmFseXNpcyB1c2VkIG9wdGltaXplZCAyLXN0YWdlIHBpcGVsaW5lIHdpdGggYnVkZ2V0LWF3YXJlIG1vZGVsIHNlbGVjdGlvbi5gO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3VtbWFyeSArPSBgQW5hbHlzaXMgdXNlZCBlbmhhbmNlZCBzZW1hbnRpYyBkZXRlY3Rpb24gd2l0aCBsb2NhbCBwcm9jZXNzaW5nLmA7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN1bW1hcnk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZUVtcHR5UmVwb3J0KHVzZXJuYW1lOiBzdHJpbmcpOiBBbmFseXNpc1JlcG9ydCB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdW1tYXJ5OiBgTm8gY29udGVudCBhdmFpbGFibGUgZm9yIGFuYWx5c2lzIGZvciB1c2VyICR7dXNlcm5hbWV9LmAsXHJcbiAgICAgIGNvbnRyYWRpY3Rpb25zOiBbXSxcclxuICAgICAgdGltZWxpbmU6IFtdLFxyXG4gICAgICBzdGF0czoge1xyXG4gICAgICAgIHRvdGFsQ29tbWVudHM6IDAsXHJcbiAgICAgICAgdGltZXNwYW46ICcwIGRheXMnLFxyXG4gICAgICAgIHRvcFN1YnJlZGRpdHM6IFtdLFxyXG4gICAgICAgIHNlbnRpbWVudFRyZW5kOiAwXHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZUVycm9yUmVwb3J0KHVzZXJuYW1lOiBzdHJpbmcsIGVycm9yOiBhbnkpOiBBbmFseXNpc1JlcG9ydCB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzdW1tYXJ5OiBgQW5hbHlzaXMgZmFpbGVkIGZvciAke3VzZXJuYW1lfTogJHtlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IubWVzc2FnZSA6ICdVbmtub3duIGVycm9yIG9jY3VycmVkJ31gLFxyXG4gICAgICBjb250cmFkaWN0aW9uczogW10sXHJcbiAgICAgIHRpbWVsaW5lOiBbXSxcclxuICAgICAgc3RhdHM6IHtcclxuICAgICAgICB0b3RhbENvbW1lbnRzOiAwLFxyXG4gICAgICAgIHRpbWVzcGFuOiAnMCBkYXlzJyxcclxuICAgICAgICB0b3BTdWJyZWRkaXRzOiBbXSxcclxuICAgICAgICBzZW50aW1lbnRUcmVuZDogMFxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjcmVhdGVGYWxsYmFja1JlcG9ydChjb21tZW50czogQ29tbWVudFdpdGhJZFtdLCB1c2VybmFtZTogc3RyaW5nKTogQW5hbHlzaXNSZXBvcnQge1xyXG4gICAgY29uc3Qgc3VtbWFyaWVzID0gdGhpcy5jcmVhdGVGYWxsYmFja1N1bW1hcmllcyhjb21tZW50cyk7XHJcbiAgICBjb25zdCBjb250cmFkaWN0aW9ucyA9IHRoaXMuY3JlYXRlRmFsbGJhY2tDb250cmFkaWN0aW9ucyhzdW1tYXJpZXMpO1xyXG4gICAgXHJcbiAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZVJlcG9ydChjb21tZW50cywgc3VtbWFyaWVzLCBjb250cmFkaWN0aW9ucywgdXNlcm5hbWUpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGNvbnN0IG11bHRpTW9kZWxQaXBlbGluZSA9IG5ldyBNdWx0aU1vZGVsUGlwZWxpbmUoKTsiXSwibmFtZXMiOlsiY2FjaGVTZXJ2aWNlIiwidG9rZW5CdWRnZXQiLCJNdWx0aU1vZGVsUGlwZWxpbmUiLCJzZXRWZXJib3NlIiwidmVyYm9zZSIsImRlYnVnIiwiYXJncyIsImNvbnNvbGUiLCJsb2ciLCJhbmFseXplVXNlciIsImNvbW1lbnRzIiwicG9zdHMiLCJ1c2VybmFtZSIsImxlbmd0aCIsImNhY2hlZFJlc3VsdCIsImdldEFuYWx5c2lzIiwiYWxsQ29tbWVudHMiLCJjb252ZXJ0QW5kRGVkdXBsaWNhdGVDb21tZW50cyIsImNyZWF0ZUVtcHR5UmVwb3J0IiwiYnVkZ2V0U3RhdHVzIiwiZ2V0QnVkZ2V0U3RhdHVzIiwiaXNFeGNlZWRlZCIsImNyZWF0ZUZhbGxiYWNrUmVwb3J0Iiwic3VtbWFyaWVzIiwib3B0aW1pemVkU3VtbWFyaXphdGlvbiIsImNvbnRyYWRpY3Rpb25zIiwiYW5hbHl6ZUNvbnRyYWRpY3Rpb25zIiwicmVwb3J0IiwiZ2VuZXJhdGVSZXBvcnQiLCJzZXRBbmFseXNpcyIsImVycm9yIiwiY3JlYXRlRXJyb3JSZXBvcnQiLCJhbGxJdGVtcyIsImlkQ291bnRlciIsImZvckVhY2giLCJjb21tZW50IiwiYm9keSIsInB1c2giLCJpZCIsInRleHQiLCJkYXRlIiwiY3JlYXRlZF91dGMiLCJzdWJyZWRkaXQiLCJzY29yZSIsInBlcm1hbGluayIsInR5cGUiLCJjb250ZXh0IiwibGlua190aXRsZSIsInBvc3QiLCJzZWxmdGV4dCIsImZ1bGxUZXh0IiwidGl0bGUiLCJ0cmltIiwiZGVkdXBsaWNhdGVkIiwic21hcnREZWR1cGxpY2F0aW9uIiwic29ydCIsImEiLCJiIiwiaXRlbXMiLCJjbHVzdGVycyIsIk1hcCIsIml0ZW0iLCJzaWduYXR1cmUiLCJjcmVhdGVDb250ZW50U2lnbmF0dXJlIiwiaGFzIiwic2V0IiwiZ2V0IiwiY2x1c3RlciIsInZhbHVlcyIsImJlc3QiLCJyZWR1Y2UiLCJjdXJyZW50Iiwibm9ybWFsaXplZCIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsInN1YnN0cmluZyIsImlzQXZhaWxhYmxlIiwiY3JlYXRlRmFsbGJhY2tTdW1tYXJpZXMiLCJtYXhUb2tlbnNQZXJCYXRjaCIsImJhdGNoZXMiLCJjcmVhdGVEeW5hbWljQmF0Y2hlcyIsImFsbFN1bW1hcmllcyIsInVzZU1vZGVsIiwicmVtYWluaW5nIiwicHJlbWl1bVN1bW1hcml6ZXJNb2RlbCIsInN1bW1hcml6ZXJNb2RlbCIsImkiLCJiYXRjaCIsInByb21wdCIsImJ1aWxkT3B0aW1pemVkU3VtbWFyaXphdGlvblByb21wdCIsImVzdGltYXRlZFRva2VucyIsImVzdGltYXRlVG9rZW5zIiwiY2FuQWZmb3JkIiwiZmFsbGJhY2tTdW1tYXJpZXMiLCJiYXRjaFN1bW1hcmllcyIsInN1bW1hcml6ZUJhdGNoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiY3VycmVudEJhdGNoIiwiY3VycmVudFRva2VucyIsImNvbW1lbnRUb2tlbnMiLCJjb21tZW50c1RleHQiLCJtYXAiLCJkYXRlU3RyIiwiRGF0ZSIsInRvTG9jYWxlRGF0ZVN0cmluZyIsImpvaW4iLCJtb2RlbCIsInJlc3BvbnNlIiwibWFrZU9wZW5Sb3V0ZXJSZXF1ZXN0IiwicGFyc2VTdW1tYXJpemF0aW9uUmVzcG9uc2UiLCJjcmVhdGVGYWxsYmFja0NvbnRyYWRpY3Rpb25zIiwicHJlbWl1bUNvbnRyYWRpY3Rpb25Nb2RlbCIsImNvbnRyYWRpY3Rpb25Nb2RlbCIsImJ1aWxkT3B0aW1pemVkQ29udHJhZGljdGlvblByb21wdCIsInBhcnNlQ29udHJhZGljdGlvblJlc3BvbnNlIiwic3VtbWFyaWVzVGV4dCIsInMiLCJzdW1tYXJ5IiwiZGF0YSIsImFwaUtleSIsIkVycm9yIiwiaW5wdXRUb2tlbnMiLCJtYXhPdXRwdXRUb2tlbnMiLCJmZXRjaCIsImJhc2VVcmwiLCJtZXRob2QiLCJoZWFkZXJzIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJKU09OIiwic3RyaW5naWZ5IiwibWVzc2FnZXMiLCJyb2xlIiwiY29udGVudCIsInRlbXBlcmF0dXJlIiwibWF4X3Rva2VucyIsInRvcF9wIiwib2siLCJlcnJvckRhdGEiLCJqc29uIiwiY2F0Y2giLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwicmVzcG9uc2VUZXh0IiwiY2hvaWNlcyIsIm1lc3NhZ2UiLCJvdXRwdXRUb2tlbnMiLCJyZWNvcmRVc2FnZSIsImxpbmVzIiwic3BsaXQiLCJmaWx0ZXIiLCJsaW5lIiwibWF0Y2giLCJvcmlnaW5hbENvbW1lbnQiLCJmaW5kIiwiYyIsIm1pc3NpbmdDb21tZW50cyIsInNvbWUiLCJpZDEiLCJpZDIiLCJkZXNjcmlwdGlvbiIsInN1bW1hcnkxIiwic3VtbWFyeTIiLCJjb25maWRlbmNlIiwiY2FsY3VsYXRlQ29udHJhZGljdGlvbkNvbmZpZGVuY2UiLCJjYXRlZ29yeSIsImRldGVjdENhdGVnb3J5Iiwic2xpY2UiLCJ0aW1lRGlmZiIsIk1hdGgiLCJhYnMiLCJkYXlzRGlmZiIsInN0cm9uZ09wcG9zaXRpb24iLCJwaHJhc2UiLCJpbmNsdWRlcyIsImNvbnRleHR1YWxTdWJzIiwic3ViIiwibWF4IiwibWluIiwiY3JlYXRlRW5oYW5jZWRTdW1tYXJ5IiwidHJ1bmNhdGVkIiwic2VudGltZW50IiwiZGV0ZWN0QWR2YW5jZWRTZW50aW1lbnQiLCJzdGFuY2UiLCJkZXRlY3RTdGFuY2UiLCJpbnRlbnNpdHkiLCJkZXRlY3RJbnRlbnNpdHkiLCJwb3NpdGl2ZSIsIm5lZ2F0aXZlIiwibG93ZXIiLCJwb3NDb3VudCIsIndvcmQiLCJuZWdDb3VudCIsImludGVuc2lmaWVycyIsImludGVuc2lmaWVyQ291bnQiLCJ0ZXN0IiwiaiIsImNvbnRyYWRpY3Rpb25UeXBlIiwiZGV0ZWN0U2VtYW50aWNDb250cmFkaWN0aW9uIiwidGV4dDEiLCJ0ZXh0MiIsImxvd2VyMSIsImxvd2VyMiIsIm9wcG9zaXRpb25QYXR0ZXJucyIsInBvcyIsIm5lZyIsImNvbmYiLCJkZXNjIiwicGF0dGVybiIsImhhc1BvczEiLCJwIiwiaGFzTmVnMSIsIm4iLCJoYXNQb3MyIiwiaGFzTmVnMiIsImZvcm1hdHRlZENvbnRyYWRpY3Rpb25zIiwiY29tbWVudDEiLCJjb21tZW50MiIsInN0YXRlbWVudDEiLCJzdGF0ZW1lbnQyIiwiZGF0ZXMiLCJ0b0lTT1N0cmluZyIsInN1YnJlZGRpdHMiLCJjb25maWRlbmNlU2NvcmUiLCJ1cHZvdGVzIiwiZmxvb3IiLCJyYW5kb20iLCJkb3dudm90ZXMiLCJ2ZXJpZmllZCIsInJlcXVpcmVzSHVtYW5SZXZpZXciLCJ0aW1lbGluZSIsImV2ZW50Iiwic3RhdHMiLCJjYWxjdWxhdGVTdGF0cyIsImdlbmVyYXRlU3VtbWFyeSIsInRvdGFsQ29tbWVudHMiLCJ0aW1lc3BhbiIsInRvcFN1YnJlZGRpdHMiLCJzZW50aW1lbnRUcmVuZCIsIm9sZGVzdCIsIm5ld2VzdCIsImRpZmZEYXlzIiwic3VicmVkZGl0Q291bnRzIiwiT2JqZWN0IiwiZW50cmllcyIsImFuYWx5c2lzTWV0aG9kIiwiaGlnaENvbmZpZGVuY2VDb3VudCIsImh1bWFuUmV2aWV3Q291bnQiLCJjb25zdHJ1Y3RvciIsInByb2Nlc3MiLCJlbnYiLCJPUEVOUk9VVEVSX0FQSV9LRVkiLCJ3YXJuIiwibXVsdGlNb2RlbFBpcGVsaW5lIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/services/multiModelPipeline.ts\n"));

/***/ })

});